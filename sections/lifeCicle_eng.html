<section class="box">
  <h1>Virtual DOM and Rendering in React</h1>

  <div class="description">
    <p>
      To master React, it is essential to understand how the Virtual DOM works and the rendering process.
    </p>

    <h3>üß± What is the DOM?</h3>
    <p>
      When a web page first loads, the browser creates a structure in memory called the <strong>DOM (Document Object Model)</strong>.
    </p>
    <ul>
      <li>It's a tree of nodes</li>
      <li>Each node represents an HTML element</li>
      <li>Modifying the real DOM is expensive in terms of performance</li>
    </ul>
    <p><strong>Visually:</strong></p>
    <pre><code>document
 ‚îî‚îÄ‚îÄ body
     ‚îî‚îÄ‚îÄ div
         ‚îú‚îÄ‚îÄ h1
         ‚îî‚îÄ‚îÄ button</code></pre>

    <h3>‚ö° The Problem with the Traditional DOM</h3>
    <p>If every change in the interface directly modified the DOM:</p>
    <ul>
      <li>‚ùå It would be slow</li>
      <li>‚ùå It would cause many repaints</li>
      <li>‚ùå Poor experience in large apps</li>
    </ul>
    <p><strong>This is where React comes in.</strong></p>

    <h3>ü™û What is the Virtual DOM?</h3>
    <p>
      The Virtual DOM is a <strong>lightweight copy of the real DOM</strong>, kept in memory by React.
    </p>
    <ul>
      <li>üëâ It's not the browser's DOM</li>
      <li>üëâ It's a JavaScript representation</li>
    </ul>
    <p>
      React works with the Virtual DOM first and only touches the real DOM when necessary.
    </p>

    <h3>üîÅ React Rendering Process (Step by Step)</h3>

    <h4>1Ô∏è‚É£ Initial Rendering</h4>
    <ul>
      <li>React creates the Virtual DOM</li>
      <li>The real DOM is generated and the UI is painted</li>
    </ul>
    <pre><code>Virtual DOM  ‚Üí  Real DOM  ‚Üí  Screen</code></pre>

    <h4>2Ô∏è‚É£ State Change (state or props)</h4>
    <p>When something changes in the application:</p>
    <ul>
      <li>React doesn't touch the real DOM directly</li>
      <li>It creates a new Virtual DOM</li>
    </ul>
    <pre><code>Virtual DOM (previous)
Virtual DOM (new)</code></pre>

    <h4>3Ô∏è‚É£ Diffing (Comparison)</h4>
    <p>React compares both versions:</p>
    <pre><code>BEFORE: &lt;h1&gt;Hello&lt;/h1&gt;
AFTER: &lt;h1&gt;Hello Roge&lt;/h1&gt;</code></pre>
    <p>üëâ It only detects what changed</p>

    <h4>4Ô∏è‚É£ Efficient Update</h4>
    <ul>
      <li>React updates only that node</li>
      <li>The rest of the DOM remains intact</li>
    </ul>
    <ul>
      <li>‚úÖ Faster</li>
      <li>‚úÖ More efficient</li>
      <li>‚úÖ Better performance</li>
    </ul>

    <h3>üß† Why is React So Fast?</h3>
    <p>Because it:</p>
    <ul>
      <li>Minimizes access to the real DOM</li>
      <li>Batches changes</li>
      <li>Updates only what's necessary</li>
    </ul>
    <p>This process is known as <strong>diffing + reconciliation</strong>.</p>

    <h3>üî• Advanced Tip</h3>
    <p>
      Although we often talk about the "Virtual DOM", internally React uses a
      <strong>Fiber-based reconciliation system</strong>, which allows it to pause, prioritize,
      and resume renders to improve user experience.
    </p>

    <h3>üéØ Conclusion</h3>
    <p>
      <strong>React doesn't update the interface directly. First it thinks, compares, and decides.</strong><br>
      Only then does it modify the real DOM, and only where necessary.
    </p>
  </div>

  <div class="tab-buttons">
    <button class="tab-button active" data-tab="code-examples">
      Code Examples
    </button>
    <button class="tab-button" data-tab="lifecycle-examples">
      Lifecycle Examples
    </button>
  </div>

  <article id="code-examples" class="tab-content active">
    <h2>Code Examples ‚Äì Virtual DOM and Rendering in React</h2>

    <h3>1Ô∏è‚É£ Initial Rendering with createRoot</h3>
    <pre><code class="language-jsx">
// index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;App /&gt;);
    </code></pre>

    <p>üîπ At this point:</p>
    <ul>
      <li>React creates the initial Virtual DOM</li>
      <li>The real DOM is generated</li>
      <li>The UI is painted on screen for the first time</li>
    </ul>

    <h3>2Ô∏è‚É£ Component Definition</h3>
    <pre><code class="language-jsx">
// App.js
import VideoList from './VideoList';

const App = () => {
  return (
    &lt;div className="app"&gt;
      &lt;h1&gt;Welcome to Useful Development&lt;/h1&gt;
      &lt;VideoList /&gt;
    &lt;/div&gt;
  );
};

export default App;
    </code></pre>

    <pre><code class="language-jsx">
// VideoList.js
import VideoItem from './VideoItem';

const VideoList = () => {
  return (
    &lt;div className="video-list"&gt;
      &lt;VideoItem title="React Course" duration="2 hours" /&gt;
      &lt;VideoItem title="Node.js Course" duration="3 hours" /&gt;
      &lt;VideoItem title="JavaScript Course" duration="1.5 hours" /&gt;
    &lt;/div&gt;
  );
};

export default VideoList;
    </code></pre>

    <pre><code class="language-jsx">
// VideoItem.js
const VideoItem = ({ title, duration }) => {
  return (
    &lt;div className="video-item"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;Duration: {duration}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default VideoItem;
    </code></pre>

    <p>üîπ Each component contributes to creating the Virtual DOM tree.</p>

    <h3>3Ô∏è‚É£ Re-render Triggered by State Change</h3>
    <pre><code class="language-jsx">
// index.js
import { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const Root = () => {
  const [showApp, setShowApp] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setShowApp(true);
    }, 5000);

    return () => clearTimeout(timer);
  }, []);

  return showApp ? &lt;App /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Root /&gt;);
    </code></pre>

    <p><strong>üß† Key point to understand React:</strong></p>
    <ul>
      <li>Every time state changes, React re-executes the component</li>
      <li>‚Üí creates a new Virtual DOM</li>
      <li>‚Üí compares it with the previous one</li>
    </ul>

    <h3>4Ô∏è‚É£ What Happens Internally? (Virtual DOM)</h3>
    <p>‚ö†Ô∏è This is NOT real React code, it's a conceptual representation:</p>
    <pre><code class="language-jsx">
const virtualDOM = {
  type: 'div',
  props: { className: 'app' },
  children: [
    { type: 'h1', children: ['Welcome to Useful Development'] },
    { type: VideoList }
  ]
};
    </code></pre>

    <p>üîπ React compares:</p>
    <ul>
      <li>Previous Virtual DOM</li>
      <li>New Virtual DOM</li>
    </ul>

    <p>üîπ And only updates the differences in the real DOM<br>(This process is called <strong>diffing</strong>).</p>

    <h3>5Ô∏è‚É£ Basic Component Pattern</h3>
    <pre><code class="language-jsx">
import ComponentA from "./ComponentA";

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ComponentA /&gt;
    &lt;/div&gt;
  );
}
    </code></pre>

    <p>üîπ React always renders:</p>
    <ul>
      <li>Components</li>
      <li>Not "full screens"</li>
      <li>Not loose HTML</li>
    </ul>

    <h2>üéØ Improved Conclusion</h2>
    <p>
      <strong>React doesn't update the DOM directly.</strong><br>
      First, it creates a new Virtual DOM, compares it with the previous one, and only applies the necessary changes.<br>
      This makes applications faster, more predictable, and easier to maintain.
    </p>
  </article>

  <article id="lifecycle-examples" class="tab-content">
    <h2>Life Cycle in Relation to Virtual DOM and Rendering</h2>
    <p>
      The Virtual DOM plays a crucial role in each phase of the component's life
      cycle:
    </p>

    <h3>Mounting:</h3>
    <ul>
      <li>
        When a component is mounted, React creates its representation in the
        Virtual DOM.
      </li>
      <li>
        The render() method (or the return in functional components) defines
        what is rendered.
      </li>
      <li>
        React compares the Virtual DOM with the real DOM and updates only what
        is necessary.
      </li>
    </ul>

    <h3>Updating:</h3>
    <ul>
      <li>
        When state or props change, React generates a new version of the Virtual
        DOM.
      </li>
      <li>
        It uses the diffing algorithm to identify the differences between the
        previous and new versions.
      </li>
      <li>
        Only the changed parts of the real DOM are updated, optimizing
        performance.
      </li>
    </ul>

    <h3>Unmounting:</h3>
    <ul>
      <li>
        React removes the component's representation from the Virtual DOM.
      </li>
      <li>
        Cleanup methods (componentWillUnmount or the cleanup function in
        useEffect) are executed.
      </li>
    </ul>

    <p>
      This approach allows React to efficiently manage interface updates,
      minimizing direct and costly manipulations of the real DOM, resulting in
      faster and more responsive applications.
    </p>

    <h2>Practical Life Cycle Examples</h2>
    <p>
      Below are examples demonstrating how the different life cycle phases
      interact with the Virtual DOM and the rendering process.
    </p>

    <h3>Example 1: Mounting and Updating with Functional Components</h3>
    <pre><code class="language-javascript">
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';

const VideoItem = ({ title, duration }) => {
  useEffect(() => {
    console.log(`VideoItem Mounted: ${title}`);

    return () => {
      console.log(`VideoItem Unmounted: ${title}`);
    };
  }, [title]);

  return (
    &lt;div className="video-item"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;Duration: {duration}&lt;/p&gt;
    &lt;/div&gt;
  );
};

const VideoList = () => {
  const [showReactCourse, setShowReactCourse] = useState(true);

  return (
    &lt;div&gt;
      {showReactCourse && &lt;VideoItem title="React Course" duration="2 hours" /&gt;}
      &lt;button onClick={() => setShowReactCourse(!showReactCourse)}&gt;
        Toggle React Course
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;VideoList /&gt;);
    </code></pre>
  </article>
</section>
