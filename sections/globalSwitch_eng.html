<section class="box">
  <h1>Global Switch with React Context (Dark/Light Mode)</h1>

  <div class="tab-buttons">
    <button class="tab-button active" data-tab="key-ideas">
      Key Ideas
    </button>
    <button class="tab-button" data-tab="concept">
      The Concept
    </button>
    <button class="tab-button" data-tab="implementation">
      Complete Implementation
    </button>
  </div>

  <article id="key-ideas" class="tab-content active">
    <h2>0) The Key Idea (Why React Context)</h2>
    <p>
      When you have <strong>global state</strong> (like theme), if you pass it through props across many components, you create <strong>prop drilling</strong>: props that "travel" through components that don't even use them.
    </p>
    <p>
      In your PDF, the concept is shown as <strong>"broadcast global state"</strong>: instead of passing props down every level, you connect components to the context and they read what they need directly.
    </p>

    <h2>1) The Problem: Prop Drilling</h2>
    <pre><code class="language-text">
App (has state theme)
â”‚
â”œâ”€ Header   (does NOT use theme, but receives it)
â”‚   â””â”€ Nav  (does NOT use theme, but receives it)
â”‚       â””â”€ Toggle (YES, uses it)
â”‚
â””â”€ MovieList (does NOT use theme, but receives it)
    â””â”€ MovieCard (YES, uses it)
        â””â”€ Title (YES, uses it)

Result:
- Props travel through layers that don't need them.
- More coupling, more noise, more maintenance.
    </code></pre>

    <h2>2) The Solution: React Context "Broadcast"</h2>
    <pre><code class="language-text">
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ ThemeProvider (TOP COMPONENT) â”‚
                 â”‚                               â”‚
                 â”‚  useState(activeTheme)        â”‚
                 â”‚  setTheme(themeKey)           â”‚
                 â”‚   â””â”€ setActiveTheme(...)      â”‚
                 â”‚                               â”‚
                 â”‚  &lt;ThemeContext.Provider       â”‚
                 â”‚     value={{                  â”‚
                 â”‚       theme,                  â”‚
                 â”‚       setTheme                â”‚
                 â”‚     }}&gt;                       â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚  (broadcast)
                                 â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚           App / Tree          â”‚
            â”‚    (everything inside)        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼                     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MovieCard     â”‚    â”‚ Styled comps  â”‚     â”‚ DarkModeToggle  â”‚
â”‚ useContext    â”‚    â”‚ useContext    â”‚     â”‚ useContext      â”‚
â”‚ reads theme   â”‚    â”‚ change colors â”‚     â”‚ calls setTheme()â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    </code></pre>

    <p><strong>Key Idea (from your PDF):</strong></p>
    <ul>
      <li>âœ… "All the state lives in the Provider"</li>
      <li>âœ… It's "broadcast" to all components below</li>
      <li>âœ… No need to pass props through every level</li>
    </ul>

    <h2>3) What Happens When You Toggle (The "Refresh")</h2>
    <p>Your PDF says: "We pass state modifier downâ€¦ and that refreshes all connected components".</p>
    <pre><code class="language-text">
User clicks Toggle button
        â”‚
        â–¼
DarkModeToggle calls: setTheme("DARK")
        â”‚
        â–¼
ThemeProvider executes:
setActiveTheme(themeList["DARK"])
        â”‚
        â–¼
React re-renders ThemeProvider
(value changes: theme is now DARK)
        â”‚
        â–¼
React re-renders ONLY consumers of ThemeContext
(MovieCard, Styled components, etc.)
        â”‚
        â–¼
UI changes colors / styles
    </code></pre>

    <h2>4) The Provider's Value Object (Most Important)</h2>
    <p>Your PDF describes value as an object with theme and setTheme.</p>
    <pre><code class="language-jsx">
ThemeContext value = {
  theme: activeTheme,         // current state (anyone can READ)
  setTheme: (themeKey) =&gt; {   // "state modifier" (anyone can CALL)
     setActiveTheme(themeList[themeKey])
  }
}

Why this is powerful:

theme     â†’ any component can READ the theme
setTheme  â†’ any component can CHANGE the theme
WITHOUT passing props.
    </code></pre>

    <h2>5) Final Mental Map (One Line)</h2>
    <pre><code class="language-text">
Provider (real state) â†’ Context "broadcast" â†’ Consumers read theme
  â†’ Toggle calls setTheme â†’ Provider changes state â†’ Consumers re-render
    </code></pre>

    <h2>6) What We're Going to Build</h2>
    <p>A system where:</p>
    <ul>
      <li>There exists a global state: <code>theme</code> (light/dark)</li>
      <li>There exists a global modifier: <code>setTheme(themeKey)</code> (so any component can change it)</li>
      <li>Everything lives in a "Provider" component and is "broadcast" to the tree</li>
      <li>Components like MovieCard or DarkModeToggle read the theme from context and change styles</li>
    </ul>

    <h2>2) Step 1 â€” Define Your Types + Theme List (ThemeList)</h2>
    <p>Your notes mention that we need initial data and TypeScript to enforce the type (ThemeName).</p>
    <pre><code class="language-jsx">
// store/theme.ts
export type ThemeName = "LIGHT" | "DARK";

export type Theme = {
  foreground: string;
  background: string;
  background_secondary: string;
};

export const themeList: Record&lt;ThemeName, Theme&gt; = {
  LIGHT: {
    foreground: "#111",
    background: "#fff",
    background_secondary: "#f3f3f3",
  },
  DARK: {
    foreground: "#fff",
    background: "#111",
    background_secondary: "#222",
  },
};
    </code></pre>
    <p>
      <strong>Junior Key Point:</strong> The ThemeName type limits possible options. This way, you avoid calling setTheme("blue") by mistake.
    </p>

    <h2>3) Step 2 â€” Create the Context (createContext) with Initial Data</h2>
    <p>Your slides say: "Check react context" + "We need initial data".</p>
    <p>The context normally stores an object with:</p>
    <ul>
      <li><code>theme</code> (active theme)</li>
      <li><code>setTheme</code> (function to change it)</li>
    </ul>
    <pre><code class="language-jsx">
// store/context.tsx
import { createContext } from "react";
import type { Theme, ThemeName } from "./theme";
import { themeList } from "./theme";

type ThemeContextValue = {
  theme: Theme;
  setTheme: (themeKey: ThemeName) =&gt; void;
};

export const ThemeContext = createContext&lt;ThemeContextValue&gt;({
  theme: themeList.LIGHT,         // initial value
  setTheme: () => {},             // placeholder (replaced in Provider)
});
    </code></pre>
    <p>
      <strong>Why that "placeholder" setTheme: () => {}?</strong> Because createContext requires an initial value. The real implementation goes in the Provider.
    </p>

    <h2>4) Step 3 â€” Create the Provider: This is Where the Global State Lives</h2>
    <p>Your PDF is clear:</p>
    <ul>
      <li>"All the state lives in this component"</li>
      <li>"broadcasted to other components by using context"</li>
      <li>value has theme and setTheme</li>
      <li>setTheme receives themeKey: ThemeName and uses themeList</li>
    </ul>
    <pre><code class="language-jsx">
// store/ThemeProvider.tsx
import React, { useMemo, useState } from "react";
import { ThemeContext } from "./context";
import { themeList, type ThemeName } from "./theme";

type Props = { children: React.ReactNode };

export function ThemeProvider({ children }: Props) {
  const [activeTheme, setActiveTheme] = useState(themeList.LIGHT);

  const setTheme = (themeKey: ThemeName) =&gt; {
    setActiveTheme(themeList[themeKey]);
  };

  const value = useMemo(
    () =&gt; ({ theme: activeTheme, setTheme }),
    [activeTheme]
  );

  return &lt;ThemeContext.Provider value={value}&gt;{children}&lt;/ThemeContext.Provider&gt;;
}
    </code></pre>
    <p>
      <strong>Senior Detail:</strong> I use useMemo to avoid recreating the value object "just because". (It's not required for learning, but it helps avoid extra renders in consuming components.)
    </p>

    <h2>5) Step 4 â€” Connect the Provider to the Component Tree</h2>
    <p>This is "Connect Context to the component tree".</p>
    <p>Usually in main.tsx / index.tsx:</p>
    <pre><code class="language-jsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { ThemeProvider } from "./store/ThemeProvider";

ReactDOM.createRoot(document.getElementById("root")!).render(
  &lt;React.StrictMode&gt;
    &lt;ThemeProvider&gt;
      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/React.StrictMode&gt;
);
    </code></pre>
    <p>
      <strong>What you've accomplished:</strong> Any component inside &lt;ThemeProvider&gt; can now access theme and setTheme without props.
    </p>

    <h2>6) Step 5 â€” Consume the Context in Components (e.g., MovieCard)</h2>
    <p>Your PDF mentions "Movie card connected to context" and that the color "comes from context", and that dynamic props are modified using context.theme.foreground.</p>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function MovieCardTitle({ title }: { title: string }) {
  const { theme } = useContext(ThemeContext);

  return (
    &lt;h3 style={{ color: theme.foreground }}&gt;
      {title}
    &lt;/h3&gt;
  );
}
    </code></pre>
    <p>
      <strong>Junior Mental Model:</strong>
    </p>
    <ul>
      <li><strong>Before:</strong> App â†’ MovieList â†’ MovieCard â†’ Title passing theme through props</li>
      <li><strong>After:</strong> Title reads it directly from Context</li>
    </ul>

    <h2>7) Step 6 â€” Create the "Global Switch" (DarkModeToggle)</h2>
    <p>In your slide you see a DarkModeToggle.tsx component that:</p>
    <ul>
      <li>uses useContext</li>
      <li>depends on the active theme</li>
      <li>calls context.setTheme(ThemeName.LIGHT/DARK)</li>
      <li>is connected to the context, and when it changes, it affects the rest</li>
    </ul>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function DarkModeToggle() {
  const { theme, setTheme } = useContext(ThemeContext);

  const isDark = theme.background === "#111";

  return (
    &lt;button
      onClick={() =&gt; setTheme(isDark ? "LIGHT" : "DARK")}
    &gt;
      {isDark ? "Switch to Light" : "Switch to Dark"}
    &lt;/button&gt;
  );
}
    </code></pre>
    <p>If you want to replicate the PDF's "toggle" idea:</p>
    <ul>
      <li>defaultChecked depends on the active theme</li>
      <li>onChange changes the theme</li>
    </ul>

    <h2>8) Step 7 â€” "Connected" Styles to Theme (Styled Folder Idea)</h2>
    <p>Your PDF mentions:</p>
    <ul>
      <li>"Styled folder"</li>
      <li>components that are reflections of styled components</li>
      <li>change color because they consume context</li>
    </ul>
    <p>A typical way: create wrappers that use theme from context.</p>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function PageContainer({ children }: { children: React.ReactNode }) {
  const { theme } = useContext(ThemeContext);

  return (
    &lt;div style={{ background: theme.background, minHeight: "100vh" }}&gt;
      {children}
    &lt;/div&gt;
  );
}
    </code></pre>

    <h2>9) The Most Important Thing to Really Understand</h2>
    <h3>A) "Pass State Modifier Down"</h3>
    <p>Your slides say: "We pass state modifier downâ€¦ so the component can go all the way back change the stateâ€¦ and all components connected refresh".</p>
    <p>
      <strong>Senior Translation:</strong> Instead of just passing theme, you also pass the ability to change it: setTheme. When you call setTheme, it changes the Provider's state â†’ React re-renders Provider â†’ re-renders consumers.
    </p>
    <h3>B) Context is Not "Magic"</h3>
    <p>Context is:</p>
    <ul>
      <li>A Provider above with real state (useState / useReducer)</li>
      <li>A shared value</li>
      <li>useContext below to read it</li>
    </ul>

    <h2>10) Final Checklist (If Something Doesn't Work)</h2>
    <ul>
      <li>Does your &lt;ThemeProvider&gt; wrap &lt;App /&gt;? (if not, useContext will read the initial value and your setTheme dummy won't do anything)</li>
      <li>Does setTheme use ThemeName and themeList[themeKey]?</li>
      <li>Are your components consuming ThemeContext inside the tree?</li>
    </ul>

    <h2>Related Links</h2>
    <ul>
      <li>
        <a href="https://react.dev/reference/react/useContext" target="_blank">
          React useContext Documentation
        </a>
      </li>
      <li>
        <a href="https://react.dev/reference/react/createContext" target="_blank">
          React createContext Documentation
        </a>
      </li>
    </ul>
  </article>

  <article id="concept" class="tab-content">
    <h2>Why React Context? (The Problem: Prop Drilling)</h2>
    <p>
      When you have <strong>global state</strong> (like theme), passing it through props across many levels causes <strong>prop drilling</strong>: props travel through components that don't even use them.
    </p>

    <h3>Without Context (Prop Drilling âŒ)</h3>
    <pre><code class="language-jsx">
// Props must pass through every level:
// App -> MovieList -> MovieCard -> Title
// Even if MovieList doesn't need 'theme'!

&lt;App theme="dark" /&gt;
  &lt;MovieList theme={theme} /&gt;
    &lt;MovieCard theme={theme} /&gt;
      &lt;Title theme={theme} /&gt;
    </code></pre>

    <h3>With Context (Broadcast âœ…)</h3>
    <p>
      Instead of passing props down every level, components <strong>connect directly to the context</strong> and read what they need.
    </p>
    <pre><code class="language-jsx">
// Title reads directly from context, no props needed!
&lt;ThemeProvider&gt;
  &lt;App /&gt;
    &lt;MovieList /&gt;
      &lt;MovieCard /&gt;
        &lt;Title /&gt; {/* Reads theme from context directly */}
&lt;/ThemeProvider&gt;
    </code></pre>

    <h2>Key Principles</h2>
    <ol>
      <li><strong>Single Source of Truth:</strong> State lives in one Provider component</li>
      <li><strong>Broadcast to Tree:</strong> Value is available to all descendants</li>
      <li><strong>Pass State Modifier Down:</strong> Components can call setTheme to change global state</li>
      <li><strong>Auto Refresh:</strong> When state changes, all consuming components re-render</li>
    </ol>

    <h2>Related Links</h2>
    <ul>
      <li>
        <a href="https://react.dev/reference/react/useContext" target="_blank">
          React useContext Documentation
        </a>
      </li>
      <li>
        <a href="https://react.dev/reference/react/createContext" target="_blank">
          React createContext Documentation
        </a>
      </li>
    </ul>
  </article>

  <article id="implementation" class="tab-content">
    <h2>Complete Implementation</h2>
    <p>
      Here's how to build a global dark/light mode switcher step by step.
    </p>

    <h3>Step 1: Define Types and Theme List</h3>
    <p><strong>store/theme.ts</strong> - Create initial data and use TypeScript to enforce valid theme names.</p>
    <pre><code class="language-jsx">
export type ThemeName = "LIGHT" | "DARK";

export type Theme = {
  foreground: string;
  background: string;
  background_secondary: string;
};

export const themeList: Record&lt;ThemeName, Theme&gt; = {
  LIGHT: {
    foreground: "#111",
    background: "#fff",
    background_secondary: "#f3f3f3",
  },
  DARK: {
    foreground: "#fff",
    background: "#111",
    background_secondary: "#222",
  },
};
    </code></pre>

    <h3>Step 2: Create the Context</h3>
    <p><strong>store/context.tsx</strong> - createContext holds the shape of data we'll share.</p>
    <pre><code class="language-jsx">
import { createContext } from "react";
import type { Theme, ThemeName } from "./theme";
import { themeList } from "./theme";

type ThemeContextValue = {
  theme: Theme;
  setTheme: (themeKey: ThemeName) =&gt; void;
};

export const ThemeContext = createContext&lt;ThemeContextValue&gt;({
  theme: themeList.LIGHT,  // Initial theme
  setTheme: () => {},      // Placeholder (real implementation in Provider)
});
    </code></pre>

    <h3>Step 3: Create the Provider</h3>
    <p><strong>store/ThemeProvider.tsx</strong> - This is where "all the state lives" and gets broadcast to children.</p>
    <pre><code class="language-jsx">
import React, { useMemo, useState } from "react";
import { ThemeContext } from "./context";
import { themeList, type ThemeName } from "./theme";

type Props = { children: React.ReactNode };

export function ThemeProvider({ children }: Props) {
  const [activeTheme, setActiveTheme] = useState(themeList.LIGHT);

  const setTheme = (themeKey: ThemeName) =&gt; {
    setActiveTheme(themeList[themeKey]);
  };

  const value = useMemo(
    () =&gt; ({ theme: activeTheme, setTheme }),
    [activeTheme]
  );

  return (
    &lt;ThemeContext.Provider value={value}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}
    </code></pre>

    <h3>Step 4: Connect Provider to Tree</h3>
    <p><strong>main.tsx</strong> - Wrap your app with ThemeProvider so all components can access the context.</p>
    <pre><code class="language-jsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { ThemeProvider } from "./store/ThemeProvider";

ReactDOM.createRoot(document.getElementById("root")!).render(
  &lt;React.StrictMode&gt;
    &lt;ThemeProvider&gt;
      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/React.StrictMode&gt;
);
    </code></pre>

    <h3>Step 5: Consume Context in Components</h3>
    <p><strong>components/MovieCardTitle.tsx</strong> - Use useContext to read theme in any component.</p>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function MovieCardTitle({ title }: { title: string }) {
  const { theme } = useContext(ThemeContext);

  return (
    &lt;h3 style={{ color: theme.foreground }}&gt;
      {title}
    &lt;/h3&gt;
  );
}
    </code></pre>

    <h3>Step 6: Create the Global Switch</h3>
    <p><strong>components/DarkModeToggle.tsx</strong> - This component changes the global theme for everyone.</p>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function DarkModeToggle() {
  const { theme, setTheme } = useContext(ThemeContext);

  const isDark = theme.background === "#111";

  return (
    &lt;button
      onClick={() =&gt; setTheme(isDark ? "LIGHT" : "DARK")}
    &gt;
      {isDark ? "â˜€ï¸ Light Mode" : "ğŸŒ™ Dark Mode"}
    &lt;/button&gt;
  );
}
    </code></pre>

    <h3>Step 7: Use in Your App</h3>
    <p><strong>App.tsx</strong> - All components inside can now read and modify the theme.</p>
    <pre><code class="language-jsx">
import { useContext } from "react";
import { ThemeContext } from "./store/context";
import { DarkModeToggle } from "./components/DarkModeToggle";
import { MovieList } from "./components/MovieList";

export default function App() {
  const { theme } = useContext(ThemeContext);

  return (
    &lt;div style={{
      background: theme.background,
      color: theme.foreground,
      minHeight: "100vh",
      padding: "20px"
    }}&gt;
      &lt;header&gt;
        &lt;h1&gt;My Movies&lt;/h1&gt;
        &lt;DarkModeToggle /&gt;
      &lt;/header&gt;
      &lt;MovieList /&gt;
    &lt;/div&gt;
  );
}
    </code></pre>

    <h2>How It Works (The Flow)</h2>
    <ol>
      <li>User clicks DarkModeToggle button</li>
      <li>Button calls setTheme("DARK")</li>
      <li>Provider's state updates (activeTheme changes)</li>
      <li>Provider re-renders with new context value</li>
      <li>ALL components using useContext(ThemeContext) automatically re-render</li>
      <li>Everything sees the new theme instantly!</li>
    </ol>

    <h2>Related Links</h2>
    <ul>
      <li>
        <a href="https://react.dev/learn/passing-data-deeply-with-context" target="_blank">
          React Context Step-by-Step Guide
        </a>
      </li>
      <li>
        <a href="https://react.dev/reference/react/useMemo" target="_blank">
          React useMemo Hook
        </a>
      </li>
      <li>
        <a href="https://chatgpt.com/g/g-p-696fbea2755481919c8258fb23e8f822-react/c/698e3077-be04-8388-a042-08fce31f150f" target="_blank">
          ChatGPT React Guide
        </a>
      </li>
    </ul>
  </article>
</section>
