<section class="box">
  <h1>Virtual DOM and Rendering in React</h1>

  <div class="description">
    <p>
      To master React, it is essential to understand how the Virtual DOM works and the rendering process.
    </p>

    <h3>ğŸ§± What is the DOM?</h3>
    <p>
      When a web page first loads, the browser creates a structure in memory called the <strong>DOM (Document Object Model)</strong>.
    </p>
    <ul>
      <li>It's a tree of nodes</li>
      <li>Each node represents an HTML element</li>
      <li>Modifying the real DOM is expensive in terms of performance</li>
    </ul>
    <p><strong>Visually:</strong></p>
    <pre><code>document
 â””â”€â”€ body
     â””â”€â”€ div
         â”œâ”€â”€ h1
         â””â”€â”€ button</code></pre>

    <h3>âš¡ The Problem with the Traditional DOM</h3>
    <p>If every change in the interface directly modified the DOM:</p>
    <ul>
      <li>âŒ It would be slow</li>
      <li>âŒ It would cause many repaints</li>
      <li>âŒ Poor experience in large apps</li>
    </ul>
    <p><strong>This is where React comes in.</strong></p>

    <h3>ğŸª What is the Virtual DOM?</h3>
    <p>
      The Virtual DOM is a <strong>lightweight copy of the real DOM</strong>, kept in memory by React.
    </p>
    <ul>
      <li>ğŸ‘‰ It's not the browser's DOM</li>
      <li>ğŸ‘‰ It's a JavaScript representation</li>
    </ul>
    <p>
      React works with the Virtual DOM first and only touches the real DOM when necessary.
    </p>

    <h3>ğŸ” React Rendering Process (Step by Step)</h3>

    <h4>1ï¸âƒ£ Initial Rendering</h4>
    <ul>
      <li>React creates the Virtual DOM</li>
      <li>The real DOM is generated and the UI is painted</li>
    </ul>
    <pre><code>Virtual DOM  â†’  Real DOM  â†’  Screen</code></pre>

    <h4>2ï¸âƒ£ State Change (state or props)</h4>
    <p>When something changes in the application:</p>
    <ul>
      <li>React doesn't touch the real DOM directly</li>
      <li>It creates a new Virtual DOM</li>
    </ul>
    <pre><code>Virtual DOM (previous)
Virtual DOM (new)</code></pre>

    <h4>3ï¸âƒ£ Diffing (Comparison)</h4>
    <p>React compares both versions:</p>
    <pre><code>BEFORE: &lt;h1&gt;Hello&lt;/h1&gt;
AFTER: &lt;h1&gt;Hello Roge&lt;/h1&gt;</code></pre>
    <p>ğŸ‘‰ It only detects what changed</p>

    <h4>4ï¸âƒ£ Efficient Update</h4>
    <ul>
      <li>React updates only that node</li>
      <li>The rest of the DOM remains intact</li>
    </ul>
    <ul>
      <li>âœ… Faster</li>
      <li>âœ… More efficient</li>
      <li>âœ… Better performance</li>
    </ul>

    <h3>ğŸ§  Why is React So Fast?</h3>
    <p>Because it:</p>
    <ul>
      <li>Minimizes access to the real DOM</li>
      <li>Batches changes</li>
      <li>Updates only what's necessary</li>
    </ul>
    <p>This process is known as <strong>diffing + reconciliation</strong>.</p>

    <h3>ğŸ”¥ Advanced Tip</h3>
    <p>
      Although we often talk about the "Virtual DOM", internally React uses a
      <strong>Fiber-based reconciliation system</strong>, which allows it to pause, prioritize,
      and resume renders to improve user experience.
    </p>

    <h3>ğŸ¯ Conclusion</h3>
    <p>
      <strong>React doesn't update the interface directly. First it thinks, compares, and decides.</strong><br>
      Only then does it modify the real DOM, and only where necessary.
    </p>
  </div>

  <div class="tab-buttons">
    <button class="tab-button active" data-tab="code-examples">
      Code Examples
    </button>
    <button class="tab-button" data-tab="lifecycle-examples">
      Lifecycle Examples
    </button>
  </div>

  <article id="code-examples" class="tab-content active">
    <h2>Code Examples â€“ Virtual DOM and Rendering in React</h2>

    <h3>1ï¸âƒ£ Initial Rendering with createRoot</h3>
    <pre><code class="language-jsx">
// index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;App /&gt;);
    </code></pre>

    <p>ğŸ”¹ At this point:</p>
    <ul>
      <li>React creates the initial Virtual DOM</li>
      <li>The real DOM is generated</li>
      <li>The UI is painted on screen for the first time</li>
    </ul>

    <h3>2ï¸âƒ£ Component Definition</h3>
    <pre><code class="language-jsx">
// App.js
import VideoList from './VideoList';

const App = () => {
  return (
    &lt;div className="app"&gt;
      &lt;h1&gt;Welcome to Useful Development&lt;/h1&gt;
      &lt;VideoList /&gt;
    &lt;/div&gt;
  );
};

export default App;
    </code></pre>

    <pre><code class="language-jsx">
// VideoList.js
import VideoItem from './VideoItem';

const VideoList = () => {
  return (
    &lt;div className="video-list"&gt;
      &lt;VideoItem title="React Course" duration="2 hours" /&gt;
      &lt;VideoItem title="Node.js Course" duration="3 hours" /&gt;
      &lt;VideoItem title="JavaScript Course" duration="1.5 hours" /&gt;
    &lt;/div&gt;
  );
};

export default VideoList;
    </code></pre>

    <pre><code class="language-jsx">
// VideoItem.js
const VideoItem = ({ title, duration }) => {
  return (
    &lt;div className="video-item"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;Duration: {duration}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default VideoItem;
    </code></pre>

    <p>ğŸ”¹ Each component contributes to creating the Virtual DOM tree.</p>

    <h3>3ï¸âƒ£ Re-render Triggered by State Change</h3>
    <pre><code class="language-jsx">
// index.js
import { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const Root = () => {
  const [showApp, setShowApp] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setShowApp(true);
    }, 5000);

    return () => clearTimeout(timer);
  }, []);

  return showApp ? &lt;App /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Root /&gt;);
    </code></pre>

    <p><strong>ğŸ§  Key point to understand React:</strong></p>
    <ul>
      <li>Every time state changes, React re-executes the component</li>
      <li>â†’ creates a new Virtual DOM</li>
      <li>â†’ compares it with the previous one</li>
    </ul>

    <h3>4ï¸âƒ£ What Happens Internally? (Virtual DOM)</h3>
    <p>âš ï¸ This is NOT real React code, it's a conceptual representation:</p>
    <pre><code class="language-jsx">
const virtualDOM = {
  type: 'div',
  props: { className: 'app' },
  children: [
    { type: 'h1', children: ['Welcome to Useful Development'] },
    { type: VideoList }
  ]
};
    </code></pre>

    <p>ğŸ”¹ React compares:</p>
    <ul>
      <li>Previous Virtual DOM</li>
      <li>New Virtual DOM</li>
    </ul>

    <p>ğŸ”¹ And only updates the differences in the real DOM<br>(This process is called <strong>diffing</strong>).</p>

    <h3>5ï¸âƒ£ Basic Component Pattern</h3>
    <pre><code class="language-jsx">
import ComponentA from "./ComponentA";

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ComponentA /&gt;
    &lt;/div&gt;
  );
}
    </code></pre>

    <p>ğŸ”¹ React always renders:</p>
    <ul>
      <li>Components</li>
      <li>Not "full screens"</li>
      <li>Not loose HTML</li>
    </ul>

    <h2>ğŸ¯ Improved Conclusion</h2>
    <p>
      <strong>React doesn't update the DOM directly.</strong><br>
      First, it creates a new Virtual DOM, compares it with the previous one, and only applies the necessary changes.<br>
      This makes applications faster, more predictable, and easier to maintain.
    </p>
  </article>

  <article id="lifecycle-examples" class="tab-content">
    <h2>Life Cycle, Virtual DOM, Rendering and Real DOM (How It All Fits Together)</h2>

    <p>
      In React, when a component "lives" (mounts, updates, unmounts), two key ideas happen:
    </p>

    <ul>
      <li><strong>Render (reconciliation):</strong> React executes your component to calculate what UI should exist (a tree of elements).</li>
      <li><strong>Commit:</strong> React applies the necessary changes to the real DOM and then executes effects (useEffect).</li>
    </ul>

    <p>
      <strong>âš ï¸ Important:</strong> render does not mean "paint to the DOM". Render is calculating the result. The DOM is touched in the commit phase.
    </p>

    <h3>ğŸŸ¢ Mounting</h3>
    <ul>
      <li>React executes the component for the first time.</li>
      <li>The "virtual" tree is generated (UI representation).</li>
      <li>React commits: creates necessary nodes/attributes in the real DOM.</li>
      <li>After commit, runs <code>useEffect(() => { ... }, [])</code> (if it exists).</li>
    </ul>

    <h3>ğŸ”„ Updating</h3>
    <p>Occurs when state, props change, or the parent re-renders:</p>
    <ul>
      <li>React re-executes the component (new tree).</li>
      <li>Compares the new tree with the previous one (reconciliation / diff).</li>
      <li>In commit, updates only what changed in the real DOM.</li>
      <li>Then React executes effects:
        <ul>
          <li>If the effect has dependencies and they changed, it does:
            <ul>
              <li>previous cleanup</li>
              <li>new effect</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <h3>ğŸ”´ Unmounting</h3>
    <ul>
      <li>React removes the component from the tree.</li>
      <li>In commit, removes its nodes from the real DOM.</li>
      <li>Executes the final effect cleanup (if any).</li>
    </ul>

    <p>
      <strong>âœ… Result:</strong> React avoids touching the DOM "manually" continuously, which is why it's more efficient and consistent.
    </p>

    <h2>Practical Example (Mount / Update / Unmount) with Clear Logs</h2>

    <p>This example demonstrates:</p>
    <ul>
      <li><strong>Mount:</strong> when VideoItem appears</li>
      <li><strong>Update:</strong> when duration changes (same instance, re-render + effect if it depends)</li>
      <li><strong>Unmount:</strong> when you hide it (final cleanup)</li>
    </ul>

    <pre><code class="language-javascript">
import React, { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function VideoItem({ title, duration }) {
  console.log("[Render] VideoItem:", title, duration);

  useEffect(() => {
    console.log("[Effect mount] VideoItem mounted:", title);

    return () => {
      console.log("[Effect cleanup] VideoItem unmounted:", title);
    };
  }, []); // only mount/unmount

  useEffect(() => {
    console.log("[Effect] duration changed:", duration);

    return () => {
      console.log("[Cleanup] before next duration effect:", duration);
    };
  }, [duration]); // update + cleanup on each duration change

  return (
    &lt;div className="video-item"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;Duration: {duration}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function VideoList() {
  const [visible, setVisible] = useState(true);
  const [duration, setDuration] = useState("2 hours");

  return (
    &lt;div&gt;
      {visible && &lt;VideoItem title="React Course" duration={duration} /&gt;}

      &lt;button onClick={() => setVisible((v) => !v)}&gt;
        Toggle component (mount/unmount)
      &lt;/button&gt;

      &lt;button onClick={() => setDuration((d) => (d === "2 hours" ? "3 hours" : "2 hours"))}&gt;
        Change duration (update)
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(&lt;VideoList /&gt;);
    </code></pre>

    <h3>ğŸ“Š What You'll See in Console (Quick Mental Idea)</h3>

    <h4>On load:</h4>
    <pre><code>[Render] ...
[Effect mount] ...
[Effect] duration changed ... (first time also counts)</code></pre>

    <h4>On duration change:</h4>
    <pre><code>[Render] ...
[Cleanup] before next duration effect ...
[Effect] duration changed ...</code></pre>

    <h4>On hide:</h4>
    <pre><code>[Effect cleanup] VideoItem unmounted ...</code></pre>
  </article>
</section>
