<section class="box">
  <h1>Understanding the useRef Hook in React</h1>

  <div class="tab-buttons">
    <button class="tab-button active" data-tab="what-is-useref">
      What is useRef?
    </button>
    <button class="tab-button" data-tab="common-use-cases">
      Common Use Cases
    </button>
    <button class="tab-button" data-tab="code-examples">Code Examples</button>
    <button class="tab-button" data-tab="analogy">
      Analogy: Magic Treasure Box
    </button>
  </div>

  <article id="what-is-useref" class="tab-content active">
    <h2>What is useRef?</h2>
    <p>
      Refs allow us to create a reference to a DOM element or to a value that
      will persist between renders. They can be declared using the createRef
      command or with the useRef hook
    </p>
    <p>
      <code>useRef</code> is a React hook that allows you to persist values
      between renders without causing a re-render when the value changes. Unlike
      state variables, updating a ref does not trigger a component update. This
      makes <code>useRef</code> ideal for storing mutable values that need to
      survive across renders, such as DOM references or previous state values.
    </p>

    <ul>
      <li>
        Returns a mutable ref object with a <code>.current</code> property.
      </li>
      <li>Persists values across renders without triggering re-renders.</li>
      <li>Commonly used to reference DOM elements and store mutable values.</li>
    </ul>

    <h3>State vs. Refs</h3>
    <h4>State (<code>useState</code>):</h4>
    <ul>
      <li>
        Used to store data that influences what is rendered on the screen.
      </li>
      <li>Updating state triggers a re-render of the component.</li>
      <li>Ideal for data that should be displayed or used in the UI.</li>
    </ul>

    <h4>Refs (<code>useRef</code>):</h4>
    <ul>
      <li>
        Used to store mutable values that do not need to trigger re-renders.
      </li>
      <li>Updating a ref does not cause a component to re-render.</li>
      <li>
        Suitable for storing DOM references, timers, previous values, etc.
      </li>
    </ul>

    <h4>When to Use:</h4>
    <ul>
      <li>Use state when you want changes to trigger UI updates.</li>
      <li>
        Use refs when you need to persist values without affecting rendering.
      </li>
    </ul>
  </article>

  <article id="common-use-cases" class="tab-content">
    <h2>Common Use Cases for useRef</h2>
    <ul>
      <li>
        Referencing DOM Elements: Accessing and manipulating DOM elements
        directly (e.g., focusing an input).
      </li>
      <li>
        Storing Previous Values: Keeping track of previous state or prop values
        across renders.
      </li>
      <li>
        Persisting Mutable Values: Storing values that need to persist across
        renders but don't require UI updates (e.g., timers, intervals).
      </li>
      <li>
        Avoiding Unnecessary Re-renders: Holding values that change frequently
        but don't need to cause a re-render.
      </li>
    </ul>
  </article>

  <article id="code-examples" class="tab-content">
    <h2>Code Examples</h2>
    <h3>
      Example 1: Counting Component Renders Using <code>useState</code> vs.
      <code>useRef</code>
    </h3>
    <h4>Incorrect Approach with <code>useState</code>:</h4>
    <pre><code class="language-javascript">
import React, { useState, useEffect } from 'react';

function RenderCounter() {
  const [renderCount, setRenderCount] = useState(0);

  useEffect(() => {
    setRenderCount(prevCount => prevCount + 1);
  });

  return &lt;div&gt;Render Count: {renderCount}&lt;/div&gt;;
}

export default RenderCounter;
    </code></pre>

    <h4>Correct Approach with <code>useRef</code>:</h4>
    <pre><code class="language-javascript">
import React, { useRef, useEffect } from 'react';

function RenderCounter() {
  const renderCount = useRef(0);

  useEffect(() => {
    renderCount.current += 1;
  });

  return &lt;div&gt;Render Count: {renderCount.current}&lt;/div&gt;;
}

export default RenderCounter;
    </code></pre>

    <h3>Example 2: Referencing DOM Elements with <code>useRef</code></h3>
    <pre><code class="language-javascript">
import React, { useRef } from 'react';

function InputFocus() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    &lt;div&gt;
      &lt;input ref={inputRef} type="text" placeholder="Click the button to focus me" /&gt;
      &lt;button onClick={handleFocus}&gt;Focus Input&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default InputFocus;
    </code></pre>

    <h3>Example 3: Storing Previous State Values with <code>useRef</code></h3>
    <pre><code class="language-javascript">
import React, { useState, useRef, useEffect } from 'react';

function PreviousStateDemo() {
  const [name, setName] = useState('');
  const prevNameRef = useRef('');

  useEffect(() => {
    prevNameRef.current = name;
  }, [name]);

  const handleChange = (e) => {
    setName(e.target.value);
  };

  return (
    &lt;div&gt;
      &lt;input type="text" value={name} onChange={handleChange} placeholder="Enter your name" /&gt;
      &lt;p&gt;Current Name: {name}&lt;/p&gt;
      &lt;p&gt;Previous Name: {prevNameRef.current}&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default PreviousStateDemo;
    </code></pre>

    <h3>Example 4: Avoiding Unnecessary Re-renders with <code>useRef</code></h3>
    <pre><code class="language-javascript">
import React, { useState, useRef } from 'react';

function TimerComponent() {
  const [count, setCount] = useState(0);
  const timerIdRef = useRef(null);

  const startTimer = () => {
    if (timerIdRef.current === null) {
      timerIdRef.current = setInterval(() => {
        setCount(prevCount =&gt; prevCount + 1);
      }, 1000);
    }
  };

  const stopTimer = () => {
    if (timerIdRef.current !== null) {
      clearInterval(timerIdRef.current);
      timerIdRef.current = null;
    }
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Timer Count: {count}&lt;/p&gt;
      &lt;button onClick={startTimer} disabled={timerIdRef.current !== null}&gt;
        Start Timer
      &lt;/button&gt;
      &lt;button onClick={stopTimer} disabled={timerIdRef.current === null}&gt;
        Stop Timer
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default TimerComponent;
    </code></pre>
  </article>

  <article id="analogy" class="tab-content">
    <h2>Analogy: The Magic Treasure Box</h2>
    <p>
      Imagine a little girl named Lily who has a magic treasure box. This box is
      special because it can hold onto things without changing or making a mess
      in Lily's room.
    </p>

    <h3>How Lily Uses Her Magic Box</h3>
    <ul>
      <li>
        <strong>Storing Treasures:</strong> Every time Lily gets a new toy, she
        puts it inside the magic box. Even if she takes her toys out and plays
        with them, the box still keeps the treasures safe inside without making
        her room messy.
      </li>
      <li>
        <strong>Quick Access:</strong> When Lily wants to play with her
        treasure, she can open the box and get it quickly without searching all
        over her room.
      </li>
      <li>
        <strong>No Changes to Her Room:</strong> When Lily adds or takes away
        toys from the magic box, her room doesn't change. It stays neat and
        tidy.
      </li>
    </ul>

    <h3>How This Relates to <code>useRef</code> in React</h3>
    <p>
      Just like Lily's magic box, <code>useRef</code> is a special tool in React
      that holds onto things (like numbers or parts of your webpage) without
      changing the whole page. You can keep some information safe and use it
      whenever you need, without making your app messy or causing it to change
      too much.
    </p>

    <h3>Why Developers Love <code>useRef</code></h3>
    <ul>
      <li>
        <strong>Keeps Things Organized:</strong> Just like how Lily's magic box
        keeps her treasures safe and her room tidy, <code>useRef</code> helps
        keep important information organized in your app.
      </li>
      <li>
        <strong>Easy to Use:</strong> Lily can easily add or take out treasures
        without any trouble, just like how <code>useRef</code> makes it easy to
        manage information in React.
      </li>
    </ul>

    <h3>In Short:</h3>
    <p>
      <code>useRef</code> is like a magic treasure box that holds things for
      you. It keeps things safe and organized without making a mess, and helps
      you quickly find and use what you stored inside.
    </p>

    <div class="links">
      <h3>Related Links:</h3>
      <ul>
        <li>
          <a href="https://www.youtube.com/watch?v=t2ypzz6gJm0" target="_blank"
            >Dev Web Simplified</a
          >
        </li>
        <li>
          <a href="https://www.youtube.com/watch?v=31Ppo7yv12I" target="_blank"
            >YouTube Pedro Tech</a
          >
        </li>
        <li>
          <a
            href="https://chatgpt.com/c/670f97f6-6e88-8008-8e10-f2162f933013"
            target="_blank"
            >Chat GPT</a
          >
        </li>
        <li>
          <a
            href="https://codesandbox.io/p/sandbox/use-ref-g8d8g8"
            target="_blank"
            >Exercise</a
          >
        </li>
      </ul>
    </div>
  </article>
</section>
