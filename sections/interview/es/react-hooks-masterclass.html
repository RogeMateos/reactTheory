<section class="box">
  <h1>React Hooks: Reglas, Orden de EjecuciÃ³n y Errores Reales - Masterclass</h1>

  <div class="description">
    <p>
      En esta masterclass, entenderÃ¡s quÃ© son realmente los hooks, por quÃ© deben llamarse en el mismo orden, quÃ© pasa si rompes las reglas y cÃ³mo funcionan internamente.
    </p>

    <h2>ğŸ“Œ Objetivos de Aprendizaje</h2>
    <p>
      Al final de este tutorial, entenderÃ¡s:
    </p>
    <ul>
      <li>QuÃ© son realmente los hooks (no solo "manejan estado")</li>
      <li>Por quÃ© deben llamarse en el mismo orden</li>
      <li>QuÃ© pasa si rompes las reglas</li>
      <li>CÃ³mo funcionan internamente los hooks</li>
      <li>Errores comunes en entrevistas</li>
      <li>Diferencia entre useEffect y useLayoutEffect</li>
      <li>CÃ³mo evitar bugs reales</li>
    </ul>

    <h2>ğŸ§  QuÃ© son Realmente los Hooks</h2>
    <p>
      Los hooks permiten que los componentes funcionales:
    </p>
    <ul>
      <li>Tengan estado (useState)</li>
      <li>Ejecuten efectos secundarios (useEffect)</li>
      <li>Memoricen valores (useMemo)</li>
      <li>Accedan al DOM (useRef)</li>
    </ul>
    <p>
      Pero aquÃ­ estÃ¡ la cosa que casi nadie explicaâ€¦
    </p>
    <p>
      <strong>No se trata de lo que hacen. Se trata de cÃ³mo React los gestiona internamente.</strong>
    </p>

    <h2>âš™ï¸ CÃ³mo React Guarda los Hooks (Lo Que Casi Nadie Explica)</h2>
    <p>
      React NO identifica un hook por su nombre.
    </p>
    <p>
      React identifica los hooks por:
    </p>
    <ul>
      <li><strong>ğŸ”¢ El orden en que se ejecutan</strong></li>
    </ul>
    <p>
      Imagina que React guarda algo asÃ­ internamente:
    </p>

    <h3>Renderizado 1:</h3>
    <pre><code class="language-javascript">
Hook 1 â†’ useState
Hook 2 â†’ useEffect
Hook 3 â†’ useState
    </code></pre>

    <p>
      En el siguiente renderizado, React espera EXACTAMENTE el mismo orden:
    </p>

    <h3>Renderizado 2:</h3>
    <pre><code class="language-javascript">
Hook 1 â†’ useState
Hook 2 â†’ useEffect
Hook 3 â†’ useState
    </code></pre>

    <p>
      Si el orden cambiaâ€¦ ğŸ’¥ bugs impredecibles.
    </p>

    <h2>ğŸš¨ Las Reglas de los Hooks</h2>

    <h3>Regla 1: Solo Llama Hooks en el Nivel Superior</h3>
    <p>
      âŒ Nunca dentro de:
    </p>
    <ul>
      <li>if statements</li>
      <li>bucles</li>
      <li>funciones regulares</li>
      <li>callbacks</li>
      <li>funciones anidadas</li>
    </ul>

    <p><strong>âŒ Incorrecto:</strong></p>
    <pre><code class="language-javascript">
if (condition) {
  useEffect(() => {});
}
    </code></pre>

    <p><strong>âœ… Correcto:</strong></p>
    <pre><code class="language-javascript">
useEffect(() => {
  if (condition) {
    // lÃ³gica aquÃ­
  }
}, [condition]);
    </code></pre>

    <h3>Regla 2: Solo en Componentes o Custom Hooks</h3>
    <p><strong>âŒ Incorrecto:</strong></p>
    <pre><code class="language-javascript">
function logger() {
  useEffect(() => {});
}
    </code></pre>

    <p><strong>âœ… Correcto (custom hook):</strong></p>
    <pre><code class="language-javascript">
function useLogger(value) {
  useEffect(() => {
    console.log(value);
  }, [value]);
}

function Component() {
  useLogger("hello");
}
    </code></pre>

    <h2>ğŸ’¥ Â¿QuÃ© Pasa Si Rompes el Orden?</h2>
    <p>
      Ejemplo peligroso:
    </p>

    <pre><code class="language-javascript">
function Component({ show }) {
  useState(0);

  if (show) {
    useEffect(() => {});
  }

  useState(10);
}
    </code></pre>

    <p><strong>Renderizado 1 (show = true):</strong></p>
    <pre><code class="language-javascript">
1 â†’ useState
2 â†’ useEffect
3 â†’ useState
    </code></pre>

    <p><strong>Renderizado 2 (show = false):</strong></p>
    <pre><code class="language-javascript">
1 â†’ useState
2 â†’ useState âŒ
    </code></pre>

    <p>
      React ahora cree que el segundo useState es el useEffect.
    </p>

    <p><strong>Resultado:</strong></p>
    <ul>
      <li>Estados mezclados</li>
      <li>Valores incorrectos</li>
      <li>Bugs difÃ­ciles de depurar</li>
    </ul>

    <h2>ğŸ§© AnalogÃ­a Importante: El Archivador</h2>
    <p>
      React es como un archivador con cajones numerados:
    </p>
    <pre><code class="language-javascript">
CajÃ³n 1 â†’ Estado A
CajÃ³n 2 â†’ Efecto B
CajÃ³n 3 â†’ Estado C
    </code></pre>

    <p>
      Si un dÃ­a te saltas el cajÃ³n 2, todo lo demÃ¡s queda desplazado.
    </p>
    <p>
      <strong>AnalogÃ­a:</strong> Es como asignar asientos en una cena. Asignas asientos segÃºn el orden de llegada. Si el 1er invitado no viene pero vienen el 2do y 3ro, el 2do invitado se sienta en el asiento 1 en lugar del 2. Â¡Caos!
    </p>

    <h2>ğŸ” Dependencias en useEffect (Error Muy ComÃºn)</h2>

    <p><strong>âŒ CÃ³digo Incorrecto:</strong></p>
    <pre><code class="language-javascript">
useEffect(() => {
  fetchData(userId);
}, []);
    </code></pre>

    <p><strong>Problema:</strong></p>
    <ul>
      <li>userId puede cambiar</li>
      <li>Pero el efecto solo se ejecuta una vez</li>
      <li>Se queda con el valor inicial (cierre obsoleto)</li>
    </ul>

    <p><strong>âœ… Correcto:</strong></p>
    <pre><code class="language-javascript">
useEffect(() => {
  fetchData(userId);
}, [userId]);
    </code></pre>

    <h2>ğŸ§  Â¿QuÃ© es un Cierre Obsoleto?</h2>
    <p>
      Cuando haces esto:
    </p>

    <pre><code class="language-javascript">
useEffect(() => {
  console.log(userId);
}, []);
    </code></pre>

    <p>
      El efecto "recuerda" el userId del primer renderizado.
    </p>
    <p>
      Aunque cambie despuÃ©s, el efecto sigue usando el valor antiguo.
    </p>
    <p>
      Es como tomar una foto del valor en el momento en que creaste el efecto.
    </p>

    <p>
      <strong>AnalogÃ­a:</strong> Imagina que anotas el nÃºmero de telÃ©fono de tu amigo. MÃ¡s tarde, cambia su nÃºmero. Pero tÃº todavÃ­a tienes el nÃºmero antiguo anotado. Cada vez que llamas, usas el antiguo del pasado.
    </p>

    <h2>ğŸ— Componente vs Custom Hook</h2>

    <h3>Componente</h3>
    <ul>
      <li>Devuelve JSX</li>
      <li>Renderiza UI</li>
    </ul>

    <pre><code class="language-javascript">
function Button() {
  return &lt;button&gt;Click&lt;/button&gt;;
}
    </code></pre>

    <h3>Custom Hook</h3>
    <ul>
      <li>No devuelve JSX</li>
      <li>Reutiliza lÃ³gica</li>
    </ul>

    <pre><code class="language-javascript">
function useFetch(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData);
  }, [url]);

  return data;
}
    </code></pre>

    <p>
      Usa custom hooks cuando:
    </p>
    <ul>
      <li>Repites lÃ³gica en mÃºltiples componentes</li>
      <li>Quieres abstraer comportamiento</li>
      <li>Quieres separar UI de lÃ³gica</li>
    </ul>

    <h2>ğŸ¨ useEffect vs useLayoutEffect</h2>

    <h3>useEffect</h3>
    <ul>
      <li>Se ejecuta <strong>despuÃ©s</strong> del paint</li>
      <li>No bloquea la UI</li>
    </ul>
    <p>
      Ideal para:
    </p>
    <ul>
      <li>Obtener datos</li>
      <li>Logging</li>
      <li>Suscripciones</li>
    </ul>

    <pre><code class="language-javascript">
useEffect(() => {
  fetchData();
}, []);
    </code></pre>

    <h3>useLayoutEffect</h3>
    <ul>
      <li>Se ejecuta <strong>antes</strong> del paint</li>
      <li>Bloquea el renderizado</li>
    </ul>
    <p>
      Ãšsalo cuando necesites:
    </p>
    <ul>
      <li>Medir el DOM</li>
      <li>Ajustar layout antes de que el usuario lo vea</li>
      <li>Evitar flickering</li>
    </ul>

    <pre><code class="language-javascript">
useLayoutEffect(() => {
  const height = elementRef.current.offsetHeight;
  setHeight(height);
}, []);
    </code></pre>

    <h2>ComparaciÃ³n de Timing</h2>
    <pre><code class="language-javascript">
// useEffect (no bloquea)
Renderizado â†’ Paint navegador â†’ Se ejecuta el efecto

// useLayoutEffect (bloquea)
Renderizado â†’ Se ejecuta el efecto â†’ Paint navegador
    </code></pre>

    <h2>ğŸ¯ Respuesta Perfecta en Entrevista</h2>
    <p>
      Si preguntan: "Â¿Por quÃ© deben llamarse los hooks en el mismo orden?"
    </p>
    <p>
      <strong>Respuesta Perfecta:</strong>
    </p>
    <blockquote>
      "React se basa en el orden de llamadas de hooks para asociar estado y efectos con una instancia especÃ­fica del componente. Internamente, React mantiene una lista vinculada de hooks indexada por su orden de llamada. Si el orden cambia entre renderizaciones, React puede asignar estado o efectos incorrectamente, causando bugs impredecibles como estado desalineado con el hook incorrecto o efectos que no se disparan cuando deberÃ­an."
    </blockquote>

    <p>
      <strong>Luego aÃ±ade:</strong>
    </p>
    <blockquote>
      "Por eso no podemos llamar hooks condicionalmente o dentro de buclesâ€”el nÃºmero de hooks cambiarÃ­a entre renderizaciones, rompiendo el sistema de ordenamiento fijo. Es como una lista numerada: si saltas nÃºmeros, todo lo posterior queda desalineado."
    </blockquote>

    <h2>ğŸ”¥ Errores Reales Que Cometen Muchos Devs</h2>
    <ul>
      <li>âŒ Hooks dentro de if statements</li>
      <li>âŒ Dependencias mal definidas</li>
      <li>âŒ Usar [] sin entender closures</li>
      <li>âŒ No limpiar efectos (event listeners, suscripciones)</li>
      <li>âŒ Abusar de useLayoutEffect</li>
      <li>âŒ No memoizar callbacks cuando es necesario</li>
      <li>âŒ Bucles infinitos de efectos</li>
      <li>âŒ Modificar el orden de hooks segÃºn condiciones</li>
    </ul>

    <h2>Ejemplos de Bugs Reales</h2>

    <h3>Bug #1: ID de Usuario Obsoleto</h3>
    <pre><code class="language-javascript">
// âŒ BUG
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, []); // Â¡Falta userId!
}

// userId cambia a 2, pero el efecto no se ejecuta
// Sigue mostrando el usuario antiguo

// âœ… ARREGLADO
useEffect(() => {
  fetch(`/api/users/${userId}`)
    .then(res => res.json())
    .then(setUser);
}, [userId]); // Incluye la dependencia
    </code></pre>

    <h3>Bug #2: Event Listener No Limpiado</h3>
    <pre><code class="language-javascript">
// âŒ BUG - Memory leak
useEffect(() => {
  const handleResize = () => {
    setWidth(window.innerWidth);
  };

  window.addEventListener("resize", handleResize);
  // Â¡Sin limpieza! Los listeners se acumulan en cada renderizado
}, []);

// âœ… ARREGLADO
useEffect(() => {
  const handleResize = () => {
    setWidth(window.innerWidth);
  };

  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);
    </code></pre>

    <h3>Bug #3: Bucle Infinito</h3>
    <pre><code class="language-javascript">
// âŒ BUG - Bucle infinito
useEffect(() => {
  setCount(count + 1);
}); // Â¡Sin array de dependencias!

// Se ejecuta despuÃ©s de cada renderizado â†’ actualiza estado â†’ re-renderizado â†’ se ejecuta el efecto de nuevo

// âœ… ARREGLADO - Muchas opciones
// OpciÃ³n 1: AÃ±ade dependencia
useEffect(() => {
  if (count &lt; 5) setCount(count + 1);
}, [count]);

// OpciÃ³n 2: Usa actualizaciÃ³n funcional
useEffect(() => {
  const timer = setInterval(() => {
    setCount(c => c + 1);
  }, 1000);
  return () => clearInterval(timer);
}, []);

// OpciÃ³n 3: Array de dependencias vacÃ­o (solo una vez)
useEffect(() => {
  const timer = setTimeout(() => {
    setCount(10);
  }, 1000);
  return () => clearTimeout(timer);
}, []);
    </code></pre>

    <h2>ğŸ“Œ Puntos Clave</h2>
    <ul>
      <li>âœ… Los hooks se identifican por orden de llamada, no por nombre</li>
      <li>âœ… Siempre llama hooks en el nivel superior</li>
      <li>âœ… Siempre incluye dependencias en useEffect</li>
      <li>âœ… Usa custom hooks para extraer lÃ³gica reutilizable</li>
      <li>âœ… Entiende los cierres obsoletos</li>
      <li>âœ… Limpia los efectos (listeners, timers, suscripciones)</li>
      <li>âœ… useEffect se ejecuta despuÃ©s del paint, useLayoutEffect antes</li>
      <li>âœ… Nunca saltes hooks condicionalmente</li>
      <li>âœ… El orden importa mÃ¡s de lo que crees</li>
      <li>âœ… Si algo se siente "raro", probablemente sea un problema de orden de hooks</li>
    </ul>

    <h2>Checklist de Entrevista</h2>
    <p>
      Antes de tu entrevista, asegÃºrate de poder explicar:
    </p>
    <ul>
      <li>Por quÃ© deben estar los hooks en el mismo orden</li>
      <li>La diferencia entre [] y sin array de dependencias</li>
      <li>QuÃ© es un cierre obsoleto</li>
      <li>CÃ³mo limpiar efectos</li>
      <li>useEffect vs useLayoutEffect</li>
      <li>CuÃ¡ndo usar custom hooks</li>
      <li>Pitfalls comunes</li>
      <li>Bugs reales y soluciones</li>
    </ul>

  </div>
</section>
