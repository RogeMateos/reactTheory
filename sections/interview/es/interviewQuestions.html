<section class="box">
  <h1>Preguntas de Entrevista de React</h1>

  <div class="description">
    <p>
      Preguntas comunes de entrevistas de React con explicaciones detalladas para ayudarte a prepararte para entrevistas tÃ©cnicas.
    </p>
  </div>

  <article class="interview-question">
    <h2>ğŸ“ "Â¿CÃ³mo accederÃ­as al estado o prop anterior en React?"</h2>

    <p>En componentes funcionales de React, cada render es una nueva llamada a la funciÃ³n. Esto significa:</p>
    <ul>
      <li>No puedes simplemente decir "dame el count anterior" automÃ¡ticamente.</li>
      <li>El estado/props que lees dentro del render son siempre los valores del render actual.</li>
      <li>Si quieres el valor anterior, debes guardarlo en algÃºn lugar que sobreviva entre renders.</li>
    </ul>
    <p>Ese "algÃºn lugar" es normalmente un <strong>ref</strong>.</p>

    <h3>ğŸ§  La Idea Central (Lo que los Entrevistadores Quieren que Entiendas)</h3>

    <h4>1) useRef persiste entre renders</h4>
    <ul>
      <li>Un objeto ref (<code>ref.current</code>) mantiene la misma identidad entre renders.</li>
      <li>Actualizar <code>ref.current</code> no dispara un re-render.</li>
      <li>Por eso es perfecto para "recordar algo".</li>
    </ul>

    <h4>2) useEffect se ejecuta despuÃ©s de que el render se confirma</h4>
    <ul>
      <li>useEffect se ejecuta despuÃ©s de que React pinta la UI para ese render.</li>
      <li>Entonces, dentro del effect, puedes decir: "Ahora que la UI muestra el Ãºltimo valor, guÃ¡rdalo como el valor anterior para la prÃ³xima vez."</li>
    </ul>

    <h4>3) Combina ambos</h4>
    <ul>
      <li><strong>Durante el render:</strong> lees <code>ref.current</code> â†’ ese es el valor anterior.</li>
      <li><strong>DespuÃ©s del render:</strong> useEffect actualiza <code>ref.current</code> al valor actual.</li>
      <li><strong>Siguiente render:</strong> el ref contiene el valor de la Ãºltima vez.</li>
    </ul>
    <p>Eso es literalmente un hook <code>usePrevious</code>.</p>

    <h3>ğŸ› ï¸ Tutorial Paso a Paso: Construir usePrevious</h3>

    <h4>Paso 1 â€” Crear el hook</h4>
    <pre><code class="language-javascript">
import { useEffect, useRef } from "react";

export function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}
    </code></pre>

    <h4>Paso 2 â€” Entender quÃ© pasa en cada render</h4>
    <p>Imagina que <code>value</code> es <code>count</code>.</p>

    <p><strong>Primer render (count = 0)</strong></p>
    <ul>
      <li><code>ref.current</code> es <code>undefined</code> (nada guardado aÃºn)</li>
      <li>el hook retorna <code>undefined</code> â†’ el anterior es desconocido (esperado)</li>
      <li>effect se ejecuta despuÃ©s del pintado â†’ establece <code>ref.current = 0</code></li>
    </ul>

    <p><strong>Segundo render (count = 1)</strong></p>
    <ul>
      <li><code>ref.current</code> es <code>0</code> (guardado del Ãºltimo render)</li>
      <li>el hook retorna <code>0</code> â†’ el count anterior es 0</li>
      <li>effect se ejecuta despuÃ©s del pintado â†’ establece <code>ref.current = 1</code></li>
    </ul>

    <p>â€¦y asÃ­ sucesivamente. <strong>âœ… Por eso funciona.</strong></p>

    <h4>Paso 3 â€” Usarlo en un componente</h4>
    <pre><code class="language-javascript">
import React, { useState } from "react";
import { usePrevious } from "./usePrevious";

export default function CounterDemo() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    &lt;div&gt;
      &lt;p&gt;Actual: {count}&lt;/p&gt;
      &lt;p&gt;Anterior: {prevCount ?? "â€”"}&lt;/p&gt;

      &lt;button onClick={() => setCount((c) => c + 1)}&gt;+&lt;/button&gt;
      &lt;button onClick={() => setCount((c) => c - 1)}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}
    </code></pre>

    <h3>ğŸ’¡ Por QuÃ© a los Entrevistadores les Gusta Esta Pregunta</h3>
    <p>Porque evalÃºa si entiendes:</p>
    <ul>
      <li>Los renders son snapshots (instantÃ¡neas)</li>
      <li>Los refs persisten sin causar re-render</li>
      <li>Los effects ocurren despuÃ©s del render, asÃ­ que son ideales para "guardar el actual como anterior"</li>
    </ul>

    <h3>âš ï¸ Errores Comunes (Buenos para Mencionar en Entrevistas)</h3>

    <h4>Error 1: Usar useState para guardar el valor anterior</h4>
    <p>Puedes hacerlo, pero causa renders extra si lo actualizas. <code>useRef</code> evita eso.</p>

    <h4>Error 2: Esperar que el primer valor anterior no sea undefined</h4>
    <p>En el primer render no hay "anterior", asÃ­ que <code>undefined</code> es correcto. Puedes usar fallback con <code>??</code>.</p>

    <h4>Error 3: "Â¿Por quÃ© no establecer el ref durante el render?"</h4>
    <p>Porque sobrescribirÃ­as el valor anterior antes de retornarlo. Quieres actualizarlo despuÃ©s del render â†’ <code>useEffect</code>.</p>

    <h3>âœ… Una Respuesta Fuerte para Entrevistas (GuiÃ³n Corto)</h3>
    <blockquote>
      "React no proporciona el estado/props anterior directamente en componentes funcionales. Yo guardarÃ­a el valor actual en un ref, porque los refs persisten entre renders sin disparar re-renders. Luego actualizarÃ­a ese ref en un useEffect que se ejecuta despuÃ©s de cada render. El hook retorna ref.current, que es el valor del Ãºltimo render."
    </blockquote>
  </article>
</section>
