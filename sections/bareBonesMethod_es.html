<section class="box">
  <h1>04.1 â€” The Bare Bone Method: Arquitectura de Estado en React</h1>

  <article>
    <h2>ğŸ¯ Objetivo de esta lecciÃ³n</h2>
    <p>Aprender a:</p>
    <ul>
      <li>DiseÃ±ar primero la estructura</li>
      <li>Definir correctamente el flujo de datos</li>
      <li>Colocar el estado en el lugar correcto</li>
      <li>Evitar errores clÃ¡sicos como:
        <ul>
          <li>Props drilling innecesario</li>
          <li>Estado duplicado</li>
          <li>Global state mal usado</li>
        </ul>
      </li>
    </ul>

    <h2>ğŸ§  1. Mentalidad: Coder vs Engineer</h2>
    <p><strong>Antes de escribir cÃ³digo, piensa.</strong></p>

    <h3>âŒ Coder:</h3>
    <ul>
      <li>Empieza con useState</li>
      <li>Prueba cosas hasta que funcionen</li>
      <li>Parchea problemas</li>
    </ul>

    <h3>âœ… Engineer:</h3>
    <ul>
      <li>Define estructura</li>
      <li>Analiza flujo</li>
      <li>Decide arquitectura</li>
      <li>Luego implementa</li>
    </ul>

    <h2>ğŸ— 2. Paso 1 â€” Component Structure</h2>
    <p><strong>Nunca empieces con estado.</strong></p>
    <p>Primero rompe la UI en piezas independientes.</p>

    <h3>Ejemplo: App tipo IMDb</h3>
    <p>Componentes posibles:</p>
    <pre><code class="language-jsx">
&lt;App&gt;
  &lt;Search /&gt;
  &lt;ResultsPage&gt;
    &lt;MovieList&gt;
      &lt;MovieCard /&gt;
    &lt;/MovieList&gt;
  &lt;/ResultsPage&gt;
&lt;/App&gt;
    </code></pre>

    <h3>ğŸ” Pregunta clave:</h3>
    <p>Â¿QuÃ© partes visuales tienen responsabilidad propia?</p>

    <h3>Regla senior:</h3>
    <p><strong>Un componente = una responsabilidad clara.</strong></p>

    <h2>ğŸ”„ 3. Paso 2 â€” Data Flow</h2>
    <p>Una vez tienes la estructura, pregunta:</p>
    <p><strong>Â¿QuiÃ©n cambia el estado?</strong></p>

    <h3>Ejemplo:</h3>
    <ul>
      <li><code>&lt;Search /&gt;</code> cambia el texto</li>
      <li><code>&lt;MovieList /&gt;</code> usa ese texto</li>
      <li>Ambos necesitan el mismo valor.</li>
    </ul>

    <h3>âŒ Error comÃºn (Junior)</h3>
    <pre><code class="language-jsx">
function Search() {
  const [query, setQuery] = useState("")
}
    </code></pre>
    <p><strong>Problema:</strong> MovieList no puede acceder.</p>

    <h3>âœ… SoluciÃ³n correcta â€” Lift State Up</h3>
    <p>Mover el estado al padre comÃºn.</p>
    <pre><code class="language-jsx">
function App() {
  const [query, setQuery] = useState("")

  return (
    &lt;&gt;
      &lt;Search query={query} setQuery={setQuery} /&gt;
      &lt;MovieList query={query} /&gt;
    &lt;/&gt;
  )
}
    </code></pre>

    <h3>Principio:</h3>
    <p><strong>Si dos hermanos necesitan el mismo estado â†’ sÃºbelo al padre comÃºn.</strong></p>

    <h2>ğŸ§µ 4. Props Drilling</h2>

    <h3>Â¿QuÃ© es?</h3>
    <p>Pasar props por mÃºltiples niveles:</p>
    <pre><code class="language-text">
App
 â””â”€â”€ ResultsPage
      â””â”€â”€ MovieList
           â””â”€â”€ MovieCard
    </code></pre>

    <p>Si query se pasa por todos aunque no lo usen â†’ props drilling.</p>

    <h3>ğŸ¤” Â¿Siempre es malo?</h3>
    <p><strong>No.</strong></p>
    <ul>
      <li>âœ” 1â€“2 niveles â†’ aceptable</li>
      <li>âŒ 4â€“5 niveles â†’ mala arquitectura</li>
    </ul>

    <h2>ğŸŒ 5. Global State</h2>

    <h3>Â¿CuÃ¡ndo usarlo?</h3>
    <p>Cuando el estado:</p>
    <ul>
      <li>Es necesario en muchas partes</li>
      <li>No cambia constantemente</li>
      <li>Representa algo transversal</li>
    </ul>

    <h3>Ejemplos:</h3>
    <ul>
      <li>AutenticaciÃ³n</li>
      <li>Idioma</li>
      <li>Tema</li>
      <li>Datos de usuario</li>
    </ul>

    <h3>Ejemplo con Context</h3>
    <pre><code class="language-jsx">
const AuthContext = createContext(null)

function App() {
  const [user, setUser] = useState(null)

  return (
    &lt;AuthContext.Provider value={{ user, setUser }}&gt;
      &lt;Search /&gt;
      &lt;ResultsPage /&gt;
    &lt;/AuthContext.Provider&gt;
  )
}
    </code></pre>

    <p>Ahora cualquier componente puede acceder sin props drilling.</p>

    <h2>ğŸ§  6. Reducer â€” Cuando el estado crece</h2>
    <p>Si el estado tiene mÃºltiples transiciones:</p>
    <pre><code class="language-jsx">
const initialState = {
  status: "idle",
  data: [],
  error: null
}
    </code></pre>

    <p>Usa <code>useReducer</code>.</p>

    <pre><code class="language-jsx">
function reducer(state, action) {
  switch (action.type) {
    case "FETCH_START":
      return { ...state, status: "loading" }

    case "FETCH_SUCCESS":
      return { ...state, status: "success", data: action.payload }

    case "FETCH_ERROR":
      return { ...state, status: "error" }

    default:
      return state
  }
}
    </code></pre>

    <p>Esto convierte tu UI en una mini state machine.</p>
    <p><strong>Nivel profesional.</strong></p>

    <h2>ğŸ“œ 7. Principios Fundamentales del Estado</h2>

    <h3>1ï¸âƒ£ Usa el menor estado posible</h3>
    <p>âŒ No guardes lo que puedes derivar.</p>
    <pre><code class="language-jsx">
const fullName = firstName + lastName
    </code></pre>
    <p>No necesitas useState para eso.</p>

    <h3>2ï¸âƒ£ MantÃ©n el estado lo mÃ¡s cerca posible</h3>
    <ul>
      <li>Modal abierto â†’ local</li>
      <li>Toggle â†’ local</li>
      <li>Auth â†’ global</li>
    </ul>

    <h3>3ï¸âƒ£ Evita redundancia</h3>
    <p>âŒ Mal:</p>
    <pre><code class="language-jsx">
const [movies, setMovies]
const [filteredMovies, setFilteredMovies]
    </code></pre>

    <p>âœ” Mejor:</p>
    <pre><code class="language-jsx">
const filteredMovies = movies.filter(...)
    </code></pre>

    <p><strong>Estado derivado â‰  estado real.</strong></p>

    <h2>ğŸ§© 8. Decidir QuÃ© Tipo de Estado Usar</h2>
    <table class="state-table">
      <thead>
        <tr>
          <th>SituaciÃ³n</th>
          <th>SoluciÃ³n</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Solo un componente lo usa</td>
          <td>useState local</td>
        </tr>
        <tr>
          <td>Dos hermanos lo necesitan</td>
          <td>Lift state up</td>
        </tr>
        <tr>
          <td>Muchas partes lo usan</td>
          <td>Context / Store</td>
        </tr>
        <tr>
          <td>Estado complejo</td>
          <td>useReducer</td>
        </tr>
        <tr>
          <td>Flujo avanzado</td>
          <td>State machine</td>
        </tr>
      </tbody>
    </table>

    <h2>ğŸ Flujo Profesional Completo</h2>
    <p>Siempre sigue este orden:</p>
    <ol>
      <li>Component Structure</li>
      <li>Data Flow</li>
      <li>State Placement</li>
      <li>Logic</li>
      <li>Styling</li>
    </ol>

    <p>Si inviertes el orden â†’ deuda tÃ©cnica.</p>

    <h2>âœ… Checklist Final</h2>
    <p>Antes de terminar una feature pregÃºntate:</p>
    <ul>
      <li>â˜ Â¿DividÃ­ bien los componentes?</li>
      <li>â˜ Â¿SÃ© quiÃ©n cambia el estado?</li>
      <li>â˜ Â¿El estado estÃ¡ en el lugar correcto?</li>
      <li>â˜ Â¿Estoy duplicando estado?</li>
      <li>â˜ Â¿Necesito realmente global state?</li>
      <li>â˜ Â¿Este estado podrÃ­a ser derivado?</li>
    </ul>
    <p>Si respondes bien â†’ estÃ¡s pensando como engineer.</p>

    <h2>ğŸ“š Recursos adicionales</h2>
    <ul>
      <li><a href="https://react.dev/learn/sharing-state-between-components" target="_blank">React Docs â€” Lifting State Up</a></li>
      <li><a href="https://react.dev/reference/react/useReducer" target="_blank">React Docs â€” useReducer</a></li>
      <li><a href="https://stately.ai/viz" target="_blank">XState Visualizer (para state machines)</a></li>
      <li>Arquitectura basada en eventos</li>
      <li>Patrones de diseÃ±o en frontend</li>
      <li><a href="https://chatgpt.com/g/g-p-696fbea2755481919c8258fb23e8f822-react/c/698e74a9-6610-8390-9857-5369c211dbec" target="_blank">GuÃ­a React ChatGPT</a></li>
    </ul>

    <h2>ğŸ“ Ejercicio Propuesto</h2>
    <p>Construye una mini app con:</p>
    <ul>
      <li>Search input</li>
      <li>Movie list</li>
      <li>Login button</li>
    </ul>

    <p>Y decide:</p>
    <ul>
      <li>Â¿QuÃ© estado es local?</li>
      <li>Â¿QuÃ© estado se levanta?</li>
      <li>Â¿QuÃ© estado serÃ­a global?</li>
      <li>Â¿Necesitas reducer?</li>
    </ul>

    <h2>ğŸš€ Siguientes Pasos</h2>
    <p>Una vez que domines el bare bones method, puedes:</p>
    <ul>
      <li>ğŸ”¥ Convertir esto en componente real en TypeScript</li>
      <li>ğŸ§  Hacer una versiÃ³n para entrevista tÃ©cnica</li>
      <li>ğŸ— Integrarlo en Next.js</li>
      <li>ğŸ¨ AÃ±adir versiÃ³n visual tipo diagrama</li>
    </ul>

    <p><strong>TÃº decides el siguiente nivel ğŸš€</strong></p>
  </article>
</section>
