<section class="box">
  <h1>Global Switch con React Context (Modo Oscuro/Claro)</h1>

  <div class="tab-buttons">
    <button class="tab-button active" data-tab="key-ideas">
      Ideas Clave
    </button>
    <button class="tab-button" data-tab="concept">
      El Concepto
    </button>
    <button class="tab-button" data-tab="implementation">
      ImplementaciÃ³n Completa
    </button>
  </div>

  <article id="key-ideas" class="tab-content active">
    <h2>0) La Idea Clave (Â¿Por QuÃ© React Context?)</h2>
    <p>
      Cuando tienes <strong>estado global</strong> (como el tema), si lo pasas por props a travÃ©s de muchos componentes, creas <strong>prop drilling</strong>: props que "viajan" por componentes que ni las usan.
    </p>
    <p>
      En tu PDF, el concepto se muestra como <strong>"broadcast global state"</strong>: en vez de bajar props por cada nivel, conectas los componentes al contexto y leen lo que necesitan directamente.
    </p>

    <h2>1) El Problema: Prop Drilling</h2>
    <pre><code class="language-text">
App (tiene state theme)
â”‚
â”œâ”€ Header   (NO usa theme, pero lo recibe)
â”‚   â””â”€ Nav  (NO usa theme, pero lo recibe)
â”‚       â””â”€ Toggle (SÃ lo usa)
â”‚
â””â”€ MovieList (NO usa theme, pero lo recibe)
    â””â”€ MovieCard (SÃ lo usa)
        â””â”€ Title (SÃ lo usa)

Resultado:
- Props viajan por capas que no las necesitan.
- MÃ¡s acoplamiento, mÃ¡s ruido, mÃ¡s mantenimiento.
    </code></pre>

    <h2>2) La SoluciÃ³n: React Context "Broadcast"</h2>
    <pre><code class="language-text">
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ ThemeProvider (COMPONENTE TOP)â”‚
                 â”‚                               â”‚
                 â”‚  useState(activeTheme)        â”‚
                 â”‚  setTheme(themeKey)           â”‚
                 â”‚   â””â”€ setActiveTheme(...)      â”‚
                 â”‚                               â”‚
                 â”‚  &lt;ThemeContext.Provider       â”‚
                 â”‚     value={{                  â”‚
                 â”‚       theme,                  â”‚
                 â”‚       setTheme                â”‚
                 â”‚     }}&gt;                       â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚  (broadcast)
                                 â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚           App / Ãrbol         â”‚
            â”‚  (todo lo que estÃ© "debajo")  â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼                     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MovieCard     â”‚    â”‚ Styled comps  â”‚     â”‚ DarkModeToggle  â”‚
â”‚ useContext    â”‚    â”‚ useContext    â”‚     â”‚ useContext      â”‚
â”‚ lee theme     â”‚    â”‚ cambian color â”‚     â”‚ llama setTheme()â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    </code></pre>

    <p><strong>Idea Clave (de tu PDF):</strong></p>
    <ul>
      <li>âœ… "Todo el estado vive en el Provider"</li>
      <li>âœ… Se "broadcast" a todos los componentes debajo</li>
      <li>âœ… No necesitas pasar props por cada nivel</li>
    </ul>

    <h2>3) QuÃ© Pasa Cuando Haces Toggle (El "Refresh")</h2>
    <p>Tu PDF dice: "We pass state modifier downâ€¦ y eso refresca todos los componentes conectados".</p>
    <pre><code class="language-text">
El usuario hace click en Toggle
        â”‚
        â–¼
DarkModeToggle llama: setTheme("DARK")
        â”‚
        â–¼
ThemeProvider ejecuta:
setActiveTheme(themeList["DARK"])
        â”‚
        â–¼
React re-renderiza ThemeProvider
(value cambia: theme ahora es DARK)
        â”‚
        â–¼
React re-renderiza SOLO los consumidores de ThemeContext
(MovieCard, Styled components, etc.)
        â”‚
        â–¼
UI cambia colores / estilos
    </code></pre>

    <h2>4) El Objeto Value del Provider (Lo MÃ¡s Importante)</h2>
    <p>Tu PDF lo describe asÃ­: value es un objeto con theme y setTheme.</p>
    <pre><code class="language-jsx">
ThemeContext value = {
  theme: activeTheme,         // estado actual (cualquiera puede LEER)
  setTheme: (themeKey) =&gt; {   // "state modifier" (cualquiera puede LLAMAR)
     setActiveTheme(themeList[themeKey])
  }
}

Â¿Por quÃ© esto es potente?

theme     â†’ cualquier componente puede LEER el tema
setTheme  â†’ cualquier componente puede CAMBIAR el tema
SIN pasar props.
    </code></pre>

    <h2>5) Mapa Mental Final (Una LÃ­nea)</h2>
    <pre><code class="language-text">
Provider (estado real) â†’ Context "broadcast" â†’ Consumers leen theme
  â†’ Toggle llama setTheme â†’ Provider cambia state â†’ Consumers re-render
    </code></pre>

    <h2>6) QuÃ© Vamos a Construir</h2>
    <p>Un sistema donde:</p>
    <ul>
      <li>Existe un estado global: <code>theme</code> (light/dark)</li>
      <li>Existe un modificador global: <code>setTheme(themeKey)</code> (para que cualquier componente pueda cambiarlo)</li>
      <li>Todo vive en un componente "Provider" y se "broadcast" al Ã¡rbol</li>
      <li>Componentes como MovieCard o un DarkModeToggle leen el theme desde context y cambian estilos</li>
    </ul>

    <h2>2) Paso 1 â€” Define tus tipos + lista de temas (ThemeList)</h2>
    <p>En tus notas se menciona que necesitamos initial data y que TypeScript fuerce el tipo (ThemeName).</p>
    <pre><code class="language-jsx">
// store/theme.ts
export type ThemeName = "LIGHT" | "DARK";

export type Theme = {
  foreground: string;
  background: string;
  background_secondary: string;
};

export const themeList: Record&lt;ThemeName, Theme&gt; = {
  LIGHT: {
    foreground: "#111",
    background: "#fff",
    background_secondary: "#f3f3f3",
  },
  DARK: {
    foreground: "#fff",
    background: "#111",
    background_secondary: "#222",
  },
};
    </code></pre>
    <p>
      <strong>Punto Junior Importante:</strong> ThemeName limita las opciones posibles. AsÃ­ evitas llamar setTheme("blue") por error.
    </p>

    <h2>3) Paso 2 â€” Crea el Context (createContext) con datos iniciales</h2>
    <p>Tus slides dicen: "Check react context" + "We need initial data".</p>
    <p>El contexto normalmente guarda un objeto con:</p>
    <ul>
      <li><code>theme</code> (tema activo)</li>
      <li><code>setTheme</code> (funciÃ³n para cambiarlo)</li>
    </ul>
    <pre><code class="language-jsx">
// store/context.tsx
import { createContext } from "react";
import type { Theme, ThemeName } from "./theme";
import { themeList } from "./theme";

type ThemeContextValue = {
  theme: Theme;
  setTheme: (themeKey: ThemeName) =&gt; void;
};

export const ThemeContext = createContext&lt;ThemeContextValue&gt;({
  theme: themeList.LIGHT,         // valor inicial
  setTheme: () => {},             // placeholder (se reemplaza en Provider)
});
    </code></pre>
    <p>
      <strong>Â¿Por quÃ© ese "placeholder" setTheme: () => {}?</strong> Porque createContext exige un valor inicial. El real lo pondremos en el Provider.
    </p>

    <h2>4) Paso 3 â€” Crea el Provider: aquÃ­ vive el estado global</h2>
    <p>Tu PDF lo dice claro:</p>
    <ul>
      <li>"All the state lives in this component"</li>
      <li>"broadcasted to other components by using context"</li>
      <li>value tiene theme y setTheme</li>
      <li>setTheme recibe themeKey: ThemeName y usa themeList</li>
    </ul>
    <pre><code class="language-jsx">
// store/ThemeProvider.tsx
import React, { useMemo, useState } from "react";
import { ThemeContext } from "./context";
import { themeList, type ThemeName } from "./theme";

type Props = { children: React.ReactNode };

export function ThemeProvider({ children }: Props) {
  const [activeTheme, setActiveTheme] = useState(themeList.LIGHT);

  const setTheme = (themeKey: ThemeName) =&gt; {
    setActiveTheme(themeList[themeKey]);
  };

  const value = useMemo(
    () =&gt; ({ theme: activeTheme, setTheme }),
    [activeTheme]
  );

  return &lt;ThemeContext.Provider value={value}&gt;{children}&lt;/ThemeContext.Provider&gt;;
}
    </code></pre>
    <p>
      <strong>Detalle Senior:</strong> Uso useMemo para no recrear el objeto value "porque sÃ­". (No es obligatorio para aprender, pero ayuda a evitar renders extra en componentes consumidores.)
    </p>

    <h2>5) Paso 4 â€” Conecta el Provider al Ã¡rbol de componentes</h2>
    <p>Esto es "Connect Context to the component tree".</p>
    <p>Normalmente en main.tsx / index.tsx:</p>
    <pre><code class="language-jsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { ThemeProvider } from "./store/ThemeProvider";

ReactDOM.createRoot(document.getElementById("root")!).render(
  &lt;React.StrictMode&gt;
    &lt;ThemeProvider&gt;
      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/React.StrictMode&gt;
);
    </code></pre>
    <p>
      <strong>QuÃ© acabas de lograr:</strong> Cualquier componente dentro de &lt;ThemeProvider&gt; puede acceder a theme y setTheme sin props.
    </p>

    <h2>6) Paso 5 â€” Consumir el context en componentes (ej: MovieCard)</h2>
    <p>Tu PDF menciona "Movie card connected to context" y que el color "comes from context", y que se modifican props dinÃ¡micas usando context.theme.foreground.</p>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function MovieCardTitle({ title }: { title: string }) {
  const { theme } = useContext(ThemeContext);

  return (
    &lt;h3 style={{ color: theme.foreground }}&gt;
      {title}
    &lt;/h3&gt;
  );
}
    </code></pre>
    <p>
      <strong>Mental Model Junior:</strong>
    </p>
    <ul>
      <li><strong>Antes:</strong> App â†’ MovieList â†’ MovieCard â†’ Title pasando theme por props</li>
      <li><strong>DespuÃ©s:</strong> Title lo "lee" directo del Context</li>
    </ul>

    <h2>7) Paso 6 â€” Crear el "Global Switch" (DarkModeToggle)</h2>
    <p>En tu slide se ve un componente DarkModeToggle.tsx que:</p>
    <ul>
      <li>usa useContext</li>
      <li>depende del theme activo</li>
      <li>llama context.setTheme(ThemeName.LIGHT/DARK)</li>
      <li>estÃ¡ conectado al context, y al cambiar, afecta al resto</li>
    </ul>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function DarkModeToggle() {
  const { theme, setTheme } = useContext(ThemeContext);

  const isDark = theme.background === "#111";

  return (
    &lt;button
      onClick={() =&gt; setTheme(isDark ? "LIGHT" : "DARK")}
    &gt;
      {isDark ? "Cambiar a Claro" : "Cambiar a Oscuro"}
    &lt;/button&gt;
  );
}
    </code></pre>
    <p>Si quieres replicar la idea del PDF con "toggle":</p>
    <ul>
      <li>defaultChecked depende del theme activo</li>
      <li>onChange cambia el theme</li>
    </ul>

    <h2>8) Paso 7 â€” Estilos "conectados" al theme (styled folder idea)</h2>
    <p>Tu PDF menciona:</p>
    <ul>
      <li>"Styled folder"</li>
      <li>componentes que son reflejo de styled components</li>
      <li>cambian color porque consumen context</li>
    </ul>
    <p>Una forma tÃ­pica: crear wrappers que usan theme del context.</p>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function PageContainer({ children }: { children: React.ReactNode }) {
  const { theme } = useContext(ThemeContext);

  return (
    &lt;div style={{ background: theme.background, minHeight: "100vh" }}&gt;
      {children}
    &lt;/div&gt;
  );
}
    </code></pre>

    <h2>9) Lo mÃ¡s importante para que lo entiendas de verdad</h2>
    <h3>A) "Pasar state modifier down"</h3>
    <p>Tus slides dicen: "We pass state modifier downâ€¦ so the component can go all the way back change the stateâ€¦ and all components connected refresh".</p>
    <p>
      <strong>TraducciÃ³n Senior:</strong> En lugar de pasar solo theme, pasas tambiÃ©n la capacidad de cambiarlo: setTheme. Cuando llamas setTheme, cambia el estado del Provider â†’ React re-renderiza Provider â†’ re-renderiza consumidores.
    </p>
    <h3>B) Context no es "magia"</h3>
    <p>Context es:</p>
    <ul>
      <li>Un Provider arriba con estado real (useState / useReducer)</li>
      <li>Un value compartido</li>
      <li>useContext abajo para leerlo</li>
    </ul>

    <h2>10) Checklist final (si algo no funciona)</h2>
    <ul>
      <li>Â¿Tu &lt;ThemeProvider&gt; envuelve &lt;App /&gt;? (si no, useContext leerÃ¡ el valor inicial y tu setTheme dummy no harÃ¡ nada)</li>
      <li>Â¿setTheme usa ThemeName y el themeList[themeKey]?</li>
      <li>Â¿Los componentes consumen ThemeContext dentro del Ã¡rbol?</li>
    </ul>

    <h2>Enlaces Relacionados</h2>
    <ul>
      <li>
        <a href="https://react.dev/reference/react/useContext" target="_blank">
          DocumentaciÃ³n de React useContext
        </a>
      </li>
      <li>
        <a href="https://react.dev/reference/react/createContext" target="_blank">
          DocumentaciÃ³n de React createContext
        </a>
      </li>
    </ul>
  </article>

  <article id="concept" class="tab-content">
    <h2>Â¿Por QuÃ© React Context? (El Problema: Prop Drilling)</h2>
    <p>
      Cuando tienes <strong>estado global</strong> (como el tema), pasarlo por props a travÃ©s de muchos niveles causa <strong>prop drilling</strong>: props que "viajan" por componentes que ni las usan.
    </p>

    <h3>Sin Context (Prop Drilling âŒ)</h3>
    <pre><code class="language-jsx">
// Props deben pasar por cada nivel:
// App -> MovieList -> MovieCard -> Title
// Â¡Aunque MovieList no use 'theme'!

&lt;App theme="dark" /&gt;
  &lt;MovieList theme={theme} /&gt;
    &lt;MovieCard theme={theme} /&gt;
      &lt;Title theme={theme} /&gt;
    </code></pre>

    <h3>Con Context (Broadcast âœ…)</h3>
    <p>
      En lugar de pasar props por cada nivel, los componentes se <strong>conectan directamente al context</strong> y leen lo que necesitan.
    </p>
    <pre><code class="language-jsx">
// Title lee directamente del context, Â¡sin props!
&lt;ThemeProvider&gt;
  &lt;App /&gt;
    &lt;MovieList /&gt;
      &lt;MovieCard /&gt;
        &lt;Title /&gt; {/* Lee theme del context directamente */}
&lt;/ThemeProvider&gt;
    </code></pre>

    <h2>Principios Clave</h2>
    <ol>
      <li><strong>Fuente Ãšnica de Verdad:</strong> El estado vive en un componente Provider</li>
      <li><strong>Broadcast al Ãrbol:</strong> El valor estÃ¡ disponible para todos los descendientes</li>
      <li><strong>Pasar Modificador de Estado:</strong> Los componentes pueden llamar a setTheme para cambiar el estado global</li>
      <li><strong>ActualizaciÃ³n AutomÃ¡tica:</strong> Cuando cambia el estado, todos los componentes consumidores se re-renderizan</li>
    </ol>

    <h2>Enlaces Relacionados</h2>
    <ul>
      <li>
        <a href="https://react.dev/reference/react/useContext" target="_blank">
          DocumentaciÃ³n de React useContext
        </a>
      </li>
      <li>
        <a href="https://react.dev/reference/react/createContext" target="_blank">
          DocumentaciÃ³n de React createContext
        </a>
      </li>
    </ul>
  </article>

  <article id="implementation" class="tab-content">
    <h2>ImplementaciÃ³n Completa</h2>
    <p>
      AquÃ­ estÃ¡ cÃ³mo construir un selector global de modo oscuro/claro paso a paso.
    </p>

    <h3>Paso 1: Define Tipos y Lista de Temas</h3>
    <p><strong>store/theme.ts</strong> - Crea datos iniciales y usa TypeScript para forzar nombres de tema vÃ¡lidos.</p>
    <pre><code class="language-jsx">
export type ThemeName = "LIGHT" | "DARK";

export type Theme = {
  foreground: string;
  background: string;
  background_secondary: string;
};

export const themeList: Record&lt;ThemeName, Theme&gt; = {
  LIGHT: {
    foreground: "#111",
    background: "#fff",
    background_secondary: "#f3f3f3",
  },
  DARK: {
    foreground: "#fff",
    background: "#111",
    background_secondary: "#222",
  },
};
    </code></pre>

    <h3>Paso 2: Crear el Context</h3>
    <p><strong>store/context.tsx</strong> - createContext define la forma de los datos que compartiremos.</p>
    <pre><code class="language-jsx">
import { createContext } from "react";
import type { Theme, ThemeName } from "./theme";
import { themeList } from "./theme";

type ThemeContextValue = {
  theme: Theme;
  setTheme: (themeKey: ThemeName) =&gt; void;
};

export const ThemeContext = createContext&lt;ThemeContextValue&gt;({
  theme: themeList.LIGHT,  // Tema inicial
  setTheme: () => {},      // Placeholder (implementaciÃ³n real en Provider)
});
    </code></pre>

    <h3>Paso 3: Crear el Provider</h3>
    <p><strong>store/ThemeProvider.tsx</strong> - AquÃ­ es donde "todo el estado vive" y se broadcast a los hijos.</p>
    <pre><code class="language-jsx">
import React, { useMemo, useState } from "react";
import { ThemeContext } from "./context";
import { themeList, type ThemeName } from "./theme";

type Props = { children: React.ReactNode };

export function ThemeProvider({ children }: Props) {
  const [activeTheme, setActiveTheme] = useState(themeList.LIGHT);

  const setTheme = (themeKey: ThemeName) =&gt; {
    setActiveTheme(themeList[themeKey]);
  };

  const value = useMemo(
    () =&gt; ({ theme: activeTheme, setTheme }),
    [activeTheme]
  );

  return (
    &lt;ThemeContext.Provider value={value}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}
    </code></pre>

    <h3>Paso 4: Conectar Provider al Ãrbol</h3>
    <p><strong>main.tsx</strong> - Envuelve tu app con ThemeProvider para que todos los componentes accedan al context.</p>
    <pre><code class="language-jsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { ThemeProvider } from "./store/ThemeProvider";

ReactDOM.createRoot(document.getElementById("root")!).render(
  &lt;React.StrictMode&gt;
    &lt;ThemeProvider&gt;
      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/React.StrictMode&gt;
);
    </code></pre>

    <h3>Paso 5: Consumir Context en Componentes</h3>
    <p><strong>components/MovieCardTitle.tsx</strong> - Usa useContext para leer el tema en cualquier componente.</p>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function MovieCardTitle({ title }: { title: string }) {
  const { theme } = useContext(ThemeContext);

  return (
    &lt;h3 style={{ color: theme.foreground }}&gt;
      {title}
    &lt;/h3&gt;
  );
}
    </code></pre>

    <h3>Paso 6: Crear el Switch Global</h3>
    <p><strong>components/DarkModeToggle.tsx</strong> - Este componente cambia el tema global para todos.</p>
    <pre><code class="language-jsx">
import React, { useContext } from "react";
import { ThemeContext } from "../store/context";

export function DarkModeToggle() {
  const { theme, setTheme } = useContext(ThemeContext);

  const isDark = theme.background === "#111";

  return (
    &lt;button
      onClick={() =&gt; setTheme(isDark ? "LIGHT" : "DARK")}
    &gt;
      {isDark ? "â˜€ï¸ Modo Claro" : "ğŸŒ™ Modo Oscuro"}
    &lt;/button&gt;
  );
}
    </code></pre>

    <h3>Paso 7: Usar en tu App</h3>
    <p><strong>App.tsx</strong> - Todos los componentes dentro pueden ahora leer y modificar el tema.</p>
    <pre><code class="language-jsx">
import { useContext } from "react";
import { ThemeContext } from "./store/context";
import { DarkModeToggle } from "./components/DarkModeToggle";
import { MovieList } from "./components/MovieList";

export default function App() {
  const { theme } = useContext(ThemeContext);

  return (
    &lt;div style={{
      background: theme.background,
      color: theme.foreground,
      minHeight: "100vh",
      padding: "20px"
    }}&gt;
      &lt;header&gt;
        &lt;h1&gt;Mis PelÃ­culas&lt;/h1&gt;
        &lt;DarkModeToggle /&gt;
      &lt;/header&gt;
      &lt;MovieList /&gt;
    &lt;/div&gt;
  );
}
    </code></pre>

    <h2>CÃ³mo Funciona (El Flujo)</h2>
    <ol>
      <li>El usuario hace clic en el botÃ³n de DarkModeToggle</li>
      <li>El botÃ³n llama setTheme("DARK")</li>
      <li>El estado del Provider se actualiza (activeTheme cambia)</li>
      <li>El Provider se re-renderiza con el nuevo valor de context</li>
      <li>TODOS los componentes usando useContext(ThemeContext) se re-renderizan automÃ¡ticamente</li>
      <li>Â¡Todo ve el tema nuevo al instante!</li>
    </ol>

    <h2>Enlaces Relacionados</h2>
    <ul>
      <li>
        <a href="https://react.dev/learn/passing-data-deeply-with-context" target="_blank">
          GuÃ­a Paso a Paso de React Context
        </a>
      </li>
      <li>
        <a href="https://react.dev/reference/react/useMemo" target="_blank">
          Hook React useMemo
        </a>
      </li>
      <li>
        <a href="https://chatgpt.com/g/g-p-696fbea2755481919c8258fb23e8f822-react/c/698e3077-be04-8388-a042-08fce31f150f" target="_blank">
          GuÃ­a React ChatGPT
        </a>
      </li>
    </ul>
  </article>
</section>
