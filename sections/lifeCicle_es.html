<section class="box">
  <h1>Virtual DOM y Renderizado en React</h1>

  <div class="description">
    <p>
      Para dominar React, es fundamental entender c√≥mo funciona el Virtual DOM y el proceso de renderizado.
    </p>

    <h3>üß± ¬øQu√© es el DOM?</h3>
    <p>
      Cuando una p√°gina web se carga por primera vez, el navegador crea una estructura en memoria llamada <strong>DOM (Document Object Model)</strong>.
    </p>
    <ul>
      <li>Es un √°rbol de nodos</li>
      <li>Cada nodo representa un elemento HTML</li>
      <li>Modificar el DOM real es costoso en rendimiento</li>
    </ul>
    <p><strong>Visualmente:</strong></p>
    <pre><code>document
 ‚îî‚îÄ‚îÄ body
     ‚îî‚îÄ‚îÄ div
         ‚îú‚îÄ‚îÄ h1
         ‚îî‚îÄ‚îÄ button</code></pre>

    <h3>‚ö° El problema del DOM tradicional</h3>
    <p>Si cada cambio en la interfaz modificara directamente el DOM:</p>
    <ul>
      <li>‚ùå Ser√≠a lento</li>
      <li>‚ùå Provocar√≠a muchos repaints</li>
      <li>‚ùå Mala experiencia en apps grandes</li>
    </ul>
    <p><strong>Aqu√≠ es donde entra React.</strong></p>

    <h3>ü™û ¬øQu√© es el Virtual DOM?</h3>
    <p>
      El Virtual DOM es una <strong>copia ligera del DOM real</strong>, mantenida en memoria por React.
    </p>
    <ul>
      <li>üëâ No es el DOM del navegador</li>
      <li>üëâ Es una representaci√≥n en JavaScript</li>
    </ul>
    <p>
      React trabaja primero con el Virtual DOM y solo toca el DOM real cuando es necesario.
    </p>

    <h3>üîÅ Proceso de renderizado en React (paso a paso)</h3>

    <h4>1Ô∏è‚É£ Renderizado inicial</h4>
    <ul>
      <li>React crea el Virtual DOM</li>
      <li>Se genera el DOM real y se pinta la UI</li>
    </ul>
    <pre><code>Virtual DOM  ‚Üí  DOM Real  ‚Üí  Pantalla</code></pre>

    <h4>2Ô∏è‚É£ Cambio de estado (state o props)</h4>
    <p>Cuando cambia algo en la aplicaci√≥n:</p>
    <ul>
      <li>React no toca el DOM real directamente</li>
      <li>Crea un nuevo Virtual DOM</li>
    </ul>
    <pre><code>Virtual DOM (anterior)
Virtual DOM (nuevo)</code></pre>

    <h4>3Ô∏è‚É£ Diffing (comparaci√≥n)</h4>
    <p>React compara ambas versiones:</p>
    <pre><code>ANTES: &lt;h1&gt;Hola&lt;/h1&gt;
DESPU√âS: &lt;h1&gt;Hola Roge&lt;/h1&gt;</code></pre>
    <p>üëâ Solo detecta qu√© cambi√≥</p>

    <h4>4Ô∏è‚É£ Actualizaci√≥n eficiente</h4>
    <ul>
      <li>React actualiza solo ese nodo</li>
      <li>El resto del DOM queda intacto</li>
    </ul>
    <ul>
      <li>‚úÖ M√°s r√°pido</li>
      <li>‚úÖ M√°s eficiente</li>
      <li>‚úÖ Mejor rendimiento</li>
    </ul>

    <h3>üß† ¬øPor qu√© React es tan r√°pido?</h3>
    <p>Porque:</p>
    <ul>
      <li>Minimiza accesos al DOM real</li>
      <li>Agrupa cambios</li>
      <li>Actualiza solo lo necesario</li>
    </ul>
    <p>Este proceso es lo que se conoce como <strong>diffing + reconciliation</strong>.</p>

    <h3>üî• Tip avanzado</h3>
    <p>
      Aunque solemos hablar de "Virtual DOM", internamente React utiliza un sistema de
      <strong>reconciliaci√≥n basado en Fiber</strong>, que permite pausar, priorizar y
      reanudar renderizados para mejorar la experiencia del usuario.
    </p>

    <h3>üéØ Conclusi√≥n</h3>
    <p>
      <strong>React no actualiza la interfaz directamente. Primero piensa, compara y decide.</strong><br>
      Solo despu√©s modifica el DOM real, y √∫nicamente donde hace falta.
    </p>
  </div>

  <h2>Ejemplos de C√≥digo ‚Äì Virtual DOM y Renderizado en React</h2>

  <h3>1Ô∏è‚É£ Renderizado inicial con createRoot</h3>
  <pre><code class="language-jsx">
// index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;App /&gt;);
  </code></pre>

  <p>üîπ En este punto:</p>
  <ul>
    <li>React crea el Virtual DOM inicial</li>
    <li>Se genera el DOM real</li>
    <li>La UI se pinta por primera vez en pantalla</li>
  </ul>

  <h3>2Ô∏è‚É£ Definici√≥n de componentes</h3>
  <pre><code class="language-jsx">
// App.js
import VideoList from './VideoList';

const App = () => {
  return (
    &lt;div className="app"&gt;
      &lt;h1&gt;Bienvenido a Desarrollo √ötil&lt;/h1&gt;
      &lt;VideoList /&gt;
    &lt;/div&gt;
  );
};

export default App;
  </code></pre>

  <pre><code class="language-jsx">
// VideoList.js
import VideoItem from './VideoItem';

const VideoList = () => {
  return (
    &lt;div className="video-list"&gt;
      &lt;VideoItem title="Curso de React" duration="2 horas" /&gt;
      &lt;VideoItem title="Curso de Node.js" duration="3 horas" /&gt;
      &lt;VideoItem title="Curso de JavaScript" duration="1.5 horas" /&gt;
    &lt;/div&gt;
  );
};

export default VideoList;
  </code></pre>

  <pre><code class="language-jsx">
// VideoItem.js
const VideoItem = ({ title, duration }) => {
  return (
    &lt;div className="video-item"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;Duraci√≥n: {duration}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default VideoItem;
  </code></pre>

  <p>üîπ Cada componente contribuye a crear el √°rbol del Virtual DOM.</p>

  <h3>3Ô∏è‚É£ Re-render provocado por cambio de estado</h3>
  <pre><code class="language-jsx">
// index.js
import { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const Root = () => {
  const [showApp, setShowApp] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setShowApp(true);
    }, 5000);

    return () => clearTimeout(timer);
  }, []);

  return showApp ? &lt;App /&gt; : &lt;div&gt;Cargando...&lt;/div&gt;;
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Root /&gt;);
  </code></pre>

  <p><strong>üß† Punto clave para entender React:</strong></p>
  <ul>
    <li>Cada vez que cambia el state, React vuelve a ejecutar el componente</li>
    <li>‚Üí crea un nuevo Virtual DOM</li>
    <li>‚Üí lo compara con el anterior</li>
  </ul>

  <h3>4Ô∏è‚É£ ¬øQu√© pasa internamente? (Virtual DOM)</h3>
  <p>‚ö†Ô∏è Esto NO es c√≥digo real de React, es una representaci√≥n conceptual:</p>
  <pre><code class="language-jsx">
const virtualDOM = {
  type: 'div',
  props: { className: 'app' },
  children: [
    { type: 'h1', children: ['Bienvenido a Desarrollo √ötil'] },
    { type: VideoList }
  ]
};
  </code></pre>

  <p>üîπ React compara:</p>
  <ul>
    <li>Virtual DOM anterior</li>
    <li>Virtual DOM nuevo</li>
  </ul>

  <p>üîπ Y solo actualiza las diferencias en el DOM real<br>(Este proceso se llama <strong>diffing</strong>).</p>

  <h3>5Ô∏è‚É£ Patr√≥n b√°sico de componente</h3>
  <pre><code class="language-jsx">
import ComponentA from "./ComponentA";

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ComponentA /&gt;
    &lt;/div&gt;
  );
}
  </code></pre>

  <p>üîπ React siempre renderiza:</p>
  <ul>
    <li>Componentes</li>
    <li>No "pantallas completas"</li>
    <li>No HTML suelto</li>
  </ul>

  <h2>üéØ Conclusi√≥n mejorada</h2>
  <p>
    <strong>React no actualiza el DOM directamente.</strong><br>
    Primero crea un nuevo Virtual DOM, lo compara con el anterior y solo aplica los cambios necesarios.<br>
    Esto hace que las aplicaciones sean m√°s r√°pidas, predecibles y f√°ciles de mantener.
  </p>

  <section class="box">
    <h2>Life Cycle Relaci√≥n con el Virtual DOM y el Renderizado</h2>
    <p>
      El Virtual DOM juega un papel crucial en cada fase del ciclo de vida del
      componente:
    </p>

    <h3>Montaje:</h3>
    <ul>
      <li>
        Cuando un componente se monta, React crea su representaci√≥n en el
        Virtual DOM.
      </li>
      <li>
        El m√©todo render() (o el retorno en componentes funcionales) define qu√©
        se renderiza.
      </li>
      <li>
        React compara el Virtual DOM con el DOM real y actualiza solo lo
        necesario.
      </li>
    </ul>

    <h3>Actualizaci√≥n:</h3>
    <ul>
      <li>
        Al cambiar el estado o las props, React genera una nueva versi√≥n del
        Virtual DOM.
      </li>
      <li>
        Utiliza el algoritmo de diffing para identificar las diferencias entre
        la versi√≥n anterior y la nueva.
      </li>
      <li>
        Solo las partes del DOM real que han cambiado se actualizan, optimizando
        el rendimiento.
      </li>
    </ul>

    <h3>Desmontaje:</h3>
    <ul>
      <li>React elimina la representaci√≥n del componente en el Virtual DOM.</li>
      <li>
        Se ejecutan los m√©todos de limpieza (componentWillUnmount o la funci√≥n
        de limpieza en useEffect).
      </li>
    </ul>

    <p>
      Este enfoque permite que React maneje eficientemente las actualizaciones
      de la interfaz, minimizando las manipulaciones directas y costosas del DOM
      real, lo que resulta en aplicaciones m√°s r√°pidas y responsivas.
    </p>

    <h2>Ejemplos Pr√°cticos del Ciclo de Vida</h2>
    <p>
      A continuaci√≥n, se presentan ejemplos que demuestran c√≥mo las diferentes
      fases del ciclo de vida interact√∫an con el Virtual DOM y el proceso de
      renderizado.
    </p>

    <h3>Ejemplo 1: Montaje y Actualizaci√≥n con Componentes Funcionales</h3>
    <pre><code class="language-javascript">
  import React, { useState, useEffect } from 'react';
  import ReactDOM from 'react-dom/client';
  
  const VideoItem = ({ title, duration }) => {
    useEffect(() => {
      console.log(`VideoItem Montado: ${title}`);
  
      return () => {
        console.log(`VideoItem Desmontado: ${title}`);
      };
    }, [title]);
  
    return (
      &lt;div className="video-item"&gt;
        &lt;h2&gt;{title}&lt;/h2&gt;
        &lt;p&gt;Duraci√≥n: {duration}&lt;/p&gt;
      &lt;/div&gt;
    );
  };
  
  const VideoList = () => {
    const [videos, setVideos] = useState([
      { id: 1, title: 'Curso de React', duration: '2 horas' },
      { id: 2, title: 'Curso de Node.js', duration: '3 horas' },
    ]);
  
    const addVideo = () => {
      const newVideo = {
        id: videos.length + 1,
        title: `Curso de JavaScript ${videos.length + 1}`,
        duration: '1.5 horas',
      };
      setVideos([...videos, newVideo]);
    };
  
    return (
      &lt;div className="video-list"&gt;
        {videos.map((video) => (
          &lt;VideoItem key={video.id} title={video.title} duration={video.duration} /&gt;
        ))}
        &lt;button onClick={addVideo}&gt;A√±adir Video&lt;/button&gt;
      &lt;/div&gt;
    );
  };
  
  const App = () => {
    return (
      &lt;div className="app"&gt;
        &lt;h1&gt;Bienvenido a Desarrollo √ötil&lt;/h1&gt;
        &lt;VideoList /&gt;
      &lt;/div&gt;
    );
  };
  
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(&lt;App /&gt;);
    </code></pre>

    <h3>Explicaci√≥n:</h3>
    <h4>Montaje:</h4>
    <p>
      Al cargar la aplicaci√≥n, se montan los componentes App, VideoList y los
      primeros VideoItem. Cada VideoItem ejecuta el useEffect que registra en la
      consola que ha sido montado.
    </p>

    <h4>Actualizaci√≥n:</h4>
    <p>
      Al hacer clic en "A√±adir Video", se actualiza el estado en VideoList, lo
      que provoca una nueva renderizaci√≥n. Se monta un nuevo VideoItem,
      ejecutando nuevamente el useEffect.
    </p>

    <h4>Desmontaje:</h4>
    <p>
      Si se implementara una funcionalidad para eliminar videos, al desmontar un
      VideoItem, se ejecutar√≠a la funci√≥n de limpieza en useEffect, registrando
      en la consola que ha sido desmontado.
    </p>

    <h3>Ejemplo 2: Optimizaci√≥n con shouldComponentUpdate y React.memo</h3>

    <h4>Componentes de Clase:</h4>
    <pre><code class="language-javascript">
  import React, { Component } from 'react';
  
  class VideoItem extends Component {
    shouldComponentUpdate(nextProps) {
      // Solo actualizar si el t√≠tulo cambia
      return nextProps.title !== this.props.title;
    }
  
    render() {
      const { title, duration } = this.props;
      return (
        &lt;div className="video-item"&gt;
          &lt;h2&gt;{title}&lt;/h2&gt;
          &lt;p&gt;Duraci√≥n: {duration}&lt;/p&gt;
        &lt;/div&gt;
      );
    }
  }
  
  export default VideoItem;
    </code></pre>

    <h4>Componentes Funcionales con React.memo:</h4>
    <pre><code class="language-javascript">
  import React from 'react';
  
  const VideoItem = React.memo(({ title, duration }) => {
    console.log(`Renderizando VideoItem: ${title}`);
    return (
      &lt;div className="video-item"&gt;
        &lt;h2&gt;{title}&lt;/h2&gt;
        &lt;p&gt;Duraci√≥n: {duration}&lt;/p&gt;
      &lt;/div&gt;
    );
  }, (prevProps, nextProps) => {
    return prevProps.title === nextProps.title;
  });
  
  export default VideoItem;
    </code></pre>

    <h3>Explicaci√≥n:</h3>
    <h4>Componentes de Clase:</h4>
    <p>
      shouldComponentUpdate evita re-renderizados innecesarios verificando si
      las props han cambiado.
    </p>

    <h4>Componentes Funcionales:</h4>
    <p>
      React.memo optimiza el componente funcional evitando re-renderizados si
      las props no han cambiado. La funci√≥n de comparaci√≥n personalizada
      (prevProps, nextProps) determina si el componente debe re-renderizarse.
    </p>
  </section>

  <div class="links">
    <h3>Enlaces Relacionados:</h3>
    <a
      href="https://chatgpt.com/c/670c59c3-c770-8008-add4-1e745b1a1f0a"
      target="_blank"
      >Virtual Dom</a
    >
    <a
      href="https://chatgpt.com/share/670c5ab2-8204-8008-a459-82505f6802ae"
      target="_blank"
      >Virtual Dom y renderizado</a
    >
  </div>
</section>
