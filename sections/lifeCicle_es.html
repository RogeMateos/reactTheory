<section class="box">
  <h1>Virtual DOM y Renderizado en React</h1>

  <div class="description">
    <p>
      Para dominar React, es fundamental entender cÃ³mo funciona el Virtual DOM y el proceso de renderizado.
    </p>

    <h3>ğŸ§± Â¿QuÃ© es el DOM?</h3>
    <p>
      Cuando una pÃ¡gina web se carga por primera vez, el navegador crea una estructura en memoria llamada <strong>DOM (Document Object Model)</strong>.
    </p>
    <ul>
      <li>Es un Ã¡rbol de nodos</li>
      <li>Cada nodo representa un elemento HTML</li>
      <li>Modificar el DOM real es costoso en rendimiento</li>
    </ul>
    <p><strong>Visualmente:</strong></p>
    <pre><code>document
 â””â”€â”€ body
     â””â”€â”€ div
         â”œâ”€â”€ h1
         â””â”€â”€ button</code></pre>

    <h3>âš¡ El problema del DOM tradicional</h3>
    <p>Si cada cambio en la interfaz modificara directamente el DOM:</p>
    <ul>
      <li>âŒ SerÃ­a lento</li>
      <li>âŒ ProvocarÃ­a muchos repaints</li>
      <li>âŒ Mala experiencia en apps grandes</li>
    </ul>
    <p><strong>AquÃ­ es donde entra React.</strong></p>

    <h3>ğŸª Â¿QuÃ© es el Virtual DOM?</h3>
    <p>
      El Virtual DOM es una <strong>copia ligera del DOM real</strong>, mantenida en memoria por React.
    </p>
    <ul>
      <li>ğŸ‘‰ No es el DOM del navegador</li>
      <li>ğŸ‘‰ Es una representaciÃ³n en JavaScript</li>
    </ul>
    <p>
      React trabaja primero con el Virtual DOM y solo toca el DOM real cuando es necesario.
    </p>

    <h3>ğŸ” Proceso de renderizado en React (paso a paso)</h3>

    <h4>1ï¸âƒ£ Renderizado inicial</h4>
    <ul>
      <li>React crea el Virtual DOM</li>
      <li>Se genera el DOM real y se pinta la UI</li>
    </ul>
    <pre><code>Virtual DOM  â†’  DOM Real  â†’  Pantalla</code></pre>

    <h4>2ï¸âƒ£ Cambio de estado (state o props)</h4>
    <p>Cuando cambia algo en la aplicaciÃ³n:</p>
    <ul>
      <li>React no toca el DOM real directamente</li>
      <li>Crea un nuevo Virtual DOM</li>
    </ul>
    <pre><code>Virtual DOM (anterior)
Virtual DOM (nuevo)</code></pre>

    <h4>3ï¸âƒ£ Diffing (comparaciÃ³n)</h4>
    <p>React compara ambas versiones:</p>
    <pre><code>ANTES: &lt;h1&gt;Hola&lt;/h1&gt;
DESPUÃ‰S: &lt;h1&gt;Hola Roge&lt;/h1&gt;</code></pre>
    <p>ğŸ‘‰ Solo detecta quÃ© cambiÃ³</p>

    <h4>4ï¸âƒ£ ActualizaciÃ³n eficiente</h4>
    <ul>
      <li>React actualiza solo ese nodo</li>
      <li>El resto del DOM queda intacto</li>
    </ul>
    <ul>
      <li>âœ… MÃ¡s rÃ¡pido</li>
      <li>âœ… MÃ¡s eficiente</li>
      <li>âœ… Mejor rendimiento</li>
    </ul>

    <h3>ğŸ§  Â¿Por quÃ© React es tan rÃ¡pido?</h3>
    <p>Porque:</p>
    <ul>
      <li>Minimiza accesos al DOM real</li>
      <li>Agrupa cambios</li>
      <li>Actualiza solo lo necesario</li>
    </ul>
    <p>Este proceso es lo que se conoce como <strong>diffing + reconciliation</strong>.</p>

    <h3>ğŸ”¥ Tip avanzado</h3>
    <p>
      Aunque solemos hablar de "Virtual DOM", internamente React utiliza un sistema de
      <strong>reconciliaciÃ³n basado en Fiber</strong>, que permite pausar, priorizar y
      reanudar renderizados para mejorar la experiencia del usuario.
    </p>

    <h3>ğŸ¯ ConclusiÃ³n</h3>
    <p>
      <strong>React no actualiza la interfaz directamente. Primero piensa, compara y decide.</strong><br>
      Solo despuÃ©s modifica el DOM real, y Ãºnicamente donde hace falta.
    </p>
  </div>

  <h2>Ejemplos de CÃ³digo â€“ Virtual DOM y Renderizado en React</h2>

  <h3>1ï¸âƒ£ Renderizado inicial con createRoot</h3>
  <pre><code class="language-jsx">
// index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;App /&gt;);
  </code></pre>

  <p>ğŸ”¹ En este punto:</p>
  <ul>
    <li>React crea el Virtual DOM inicial</li>
    <li>Se genera el DOM real</li>
    <li>La UI se pinta por primera vez en pantalla</li>
  </ul>

  <h3>2ï¸âƒ£ DefiniciÃ³n de componentes</h3>
  <pre><code class="language-jsx">
// App.js
import VideoList from './VideoList';

const App = () => {
  return (
    &lt;div className="app"&gt;
      &lt;h1&gt;Bienvenido a Desarrollo Ãštil&lt;/h1&gt;
      &lt;VideoList /&gt;
    &lt;/div&gt;
  );
};

export default App;
  </code></pre>

  <pre><code class="language-jsx">
// VideoList.js
import VideoItem from './VideoItem';

const VideoList = () => {
  return (
    &lt;div className="video-list"&gt;
      &lt;VideoItem title="Curso de React" duration="2 horas" /&gt;
      &lt;VideoItem title="Curso de Node.js" duration="3 horas" /&gt;
      &lt;VideoItem title="Curso de JavaScript" duration="1.5 horas" /&gt;
    &lt;/div&gt;
  );
};

export default VideoList;
  </code></pre>

  <pre><code class="language-jsx">
// VideoItem.js
const VideoItem = ({ title, duration }) => {
  return (
    &lt;div className="video-item"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;DuraciÃ³n: {duration}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default VideoItem;
  </code></pre>

  <p>ğŸ”¹ Cada componente contribuye a crear el Ã¡rbol del Virtual DOM.</p>

  <h3>3ï¸âƒ£ Re-render provocado por cambio de estado</h3>
  <pre><code class="language-jsx">
// index.js
import { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const Root = () => {
  const [showApp, setShowApp] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setShowApp(true);
    }, 5000);

    return () => clearTimeout(timer);
  }, []);

  return showApp ? &lt;App /&gt; : &lt;div&gt;Cargando...&lt;/div&gt;;
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Root /&gt;);
  </code></pre>

  <p><strong>ğŸ§  Punto clave para entender React:</strong></p>
  <ul>
    <li>Cada vez que cambia el state, React vuelve a ejecutar el componente</li>
    <li>â†’ crea un nuevo Virtual DOM</li>
    <li>â†’ lo compara con el anterior</li>
  </ul>

  <h3>4ï¸âƒ£ Â¿QuÃ© pasa internamente? (Virtual DOM)</h3>
  <p>âš ï¸ Esto NO es cÃ³digo real de React, es una representaciÃ³n conceptual:</p>
  <pre><code class="language-jsx">
const virtualDOM = {
  type: 'div',
  props: { className: 'app' },
  children: [
    { type: 'h1', children: ['Bienvenido a Desarrollo Ãštil'] },
    { type: VideoList }
  ]
};
  </code></pre>

  <p>ğŸ”¹ React compara:</p>
  <ul>
    <li>Virtual DOM anterior</li>
    <li>Virtual DOM nuevo</li>
  </ul>

  <p>ğŸ”¹ Y solo actualiza las diferencias en el DOM real<br>(Este proceso se llama <strong>diffing</strong>).</p>

  <h3>5ï¸âƒ£ PatrÃ³n bÃ¡sico de componente</h3>
  <pre><code class="language-jsx">
import ComponentA from "./ComponentA";

export default function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ComponentA /&gt;
    &lt;/div&gt;
  );
}
  </code></pre>

  <p>ğŸ”¹ React siempre renderiza:</p>
  <ul>
    <li>Componentes</li>
    <li>No "pantallas completas"</li>
    <li>No HTML suelto</li>
  </ul>

  <h2>ğŸ¯ ConclusiÃ³n mejorada</h2>
  <p>
    <strong>React no actualiza el DOM directamente.</strong><br>
    Primero crea un nuevo Virtual DOM, lo compara con el anterior y solo aplica los cambios necesarios.<br>
    Esto hace que las aplicaciones sean mÃ¡s rÃ¡pidas, predecibles y fÃ¡ciles de mantener.
  </p>

  <section class="box">
    <h2>Life Cycle, Virtual DOM, Rendering y DOM real (cÃ³mo encaja todo)</h2>

    <p>
      En React, cuando un componente "vive" (monta, actualiza, desmonta), pasan dos ideas clave:
    </p>

    <ul>
      <li><strong>Render (reconciliaciÃ³n):</strong> React ejecuta tu componente para calcular quÃ© UI deberÃ­a existir (un Ã¡rbol de elementos).</li>
      <li><strong>Commit:</strong> React aplica los cambios necesarios al DOM real y luego ejecuta effects (useEffect).</li>
    </ul>

    <p>
      <strong>âš ï¸ Importante:</strong> render no significa "pintar en el DOM". Render es calcular el resultado. El DOM se toca en la fase de commit.
    </p>

    <h3>ğŸŸ¢ Mounting (Montaje)</h3>
    <ul>
      <li>React ejecuta el componente por primera vez.</li>
      <li>Se genera el Ã¡rbol "virtual" (representaciÃ³n de la UI).</li>
      <li>React hace commit: crea nodos/atributos necesarios en el DOM real.</li>
      <li>DespuÃ©s del commit, corre <code>useEffect(() => { ... }, [])</code> (si existe).</li>
    </ul>

    <h3>ğŸ”„ Updating (ActualizaciÃ³n)</h3>
    <p>Ocurre cuando cambian state, props, o el padre re-renderiza:</p>
    <ul>
      <li>React vuelve a ejecutar el componente (nuevo Ã¡rbol).</li>
      <li>Compara el Ã¡rbol nuevo con el anterior (reconciliation / diff).</li>
      <li>En el commit, actualiza solo lo que cambiÃ³ en el DOM real.</li>
      <li>Luego React ejecuta effects:
        <ul>
          <li>Si el effect tiene dependencias y cambiaron, hace:
            <ul>
              <li>cleanup anterior</li>
              <li>effect nuevo</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <h3>ğŸ”´ Unmounting (Desmontaje)</h3>
    <ul>
      <li>React elimina el componente del Ã¡rbol.</li>
      <li>En el commit, quita sus nodos del DOM real.</li>
      <li>Ejecuta el cleanup final del effect (si lo hay).</li>
    </ul>

    <p>
      <strong>âœ… Resultado:</strong> React evita tocar el DOM "a mano" continuamente, y por eso es mÃ¡s eficiente y consistente.
    </p>

    <h2>Ejemplo prÃ¡ctico (Mount / Update / Unmount) con logs claros</h2>

    <p>Este ejemplo demuestra:</p>
    <ul>
      <li><strong>Mount:</strong> cuando aparece el VideoItem</li>
      <li><strong>Update:</strong> cuando cambia duration (misma instancia, re-render + effect si depende)</li>
      <li><strong>Unmount:</strong> cuando lo ocultas (cleanup final)</li>
    </ul>

    <pre><code class="language-javascript">
import React, { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function VideoItem({ title, duration }) {
  console.log("[Render] VideoItem:", title, duration);

  useEffect(() => {
    console.log("[Effect mount] VideoItem mounted:", title);

    return () => {
      console.log("[Effect cleanup] VideoItem unmounted:", title);
    };
  }, []); // solo mount/unmount

  useEffect(() => {
    console.log("[Effect] duration changed:", duration);

    return () => {
      console.log("[Cleanup] before next duration effect:", duration);
    };
  }, [duration]); // update + cleanup en cada cambio de duration

  return (
    &lt;div className="video-item"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;Duration: {duration}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function VideoList() {
  const [visible, setVisible] = useState(true);
  const [duration, setDuration] = useState("2 hours");

  return (
    &lt;div&gt;
      {visible && &lt;VideoItem title="React Course" duration={duration} /&gt;}

      &lt;button onClick={() => setVisible((v) => !v)}&gt;
        Toggle component (mount/unmount)
      &lt;/button&gt;

      &lt;button onClick={() => setDuration((d) => (d === "2 hours" ? "3 hours" : "2 hours"))}&gt;
        Change duration (update)
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(&lt;VideoList /&gt;);
    </code></pre>

    <h3>ğŸ“Š QuÃ© verÃ¡s en consola (idea mental rÃ¡pida)</h3>

    <h4>Al cargar:</h4>
    <pre><code>[Render] ...
[Effect mount] ...
[Effect] duration changed ... (primera vez tambiÃ©n cuenta)</code></pre>

    <h4>Al cambiar duration:</h4>
    <pre><code>[Render] ...
[Cleanup] before next duration effect ...
[Effect] duration changed ...</code></pre>

    <h4>Al ocultar:</h4>
    <pre><code>[Effect cleanup] VideoItem unmounted ...</code></pre>
  </section>

  <div class="links">
    <h3>Enlaces Relacionados:</h3>
    <a
      href="https://chatgpt.com/c/670c59c3-c770-8008-add4-1e745b1a1f0a"
      target="_blank"
      >Virtual Dom</a
    >
    <a
      href="https://chatgpt.com/share/670c5ab2-8204-8008-a459-82505f6802ae"
      target="_blank"
      >Virtual Dom y renderizado</a
    >
  </div>
</section>
