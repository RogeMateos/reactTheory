<section class="box">
  <h1>Virtual DOM y Renderizado en React</h1>

  <div class="description">
    <p>
      Para dominar React, es fundamental entender c√≥mo funciona el Virtual DOM y el proceso de renderizado.
    </p>

    <h3>üß± ¬øQu√© es el DOM?</h3>
    <p>
      Cuando una p√°gina web se carga por primera vez, el navegador crea una estructura en memoria llamada <strong>DOM (Document Object Model)</strong>.
    </p>
    <ul>
      <li>Es un √°rbol de nodos</li>
      <li>Cada nodo representa un elemento HTML</li>
      <li>Modificar el DOM real es costoso en rendimiento</li>
    </ul>
    <p><strong>Visualmente:</strong></p>
    <pre><code>document
 ‚îî‚îÄ‚îÄ body
     ‚îî‚îÄ‚îÄ div
         ‚îú‚îÄ‚îÄ h1
         ‚îî‚îÄ‚îÄ button</code></pre>

    <h3>‚ö° El problema del DOM tradicional</h3>
    <p>Si cada cambio en la interfaz modificara directamente el DOM:</p>
    <ul>
      <li>‚ùå Ser√≠a lento</li>
      <li>‚ùå Provocar√≠a muchos repaints</li>
      <li>‚ùå Mala experiencia en apps grandes</li>
    </ul>
    <p><strong>Aqu√≠ es donde entra React.</strong></p>

    <h3>ü™û ¬øQu√© es el Virtual DOM?</h3>
    <p>
      El Virtual DOM es una <strong>copia ligera del DOM real</strong>, mantenida en memoria por React.
    </p>
    <ul>
      <li>üëâ No es el DOM del navegador</li>
      <li>üëâ Es una representaci√≥n en JavaScript</li>
    </ul>
    <p>
      React trabaja primero con el Virtual DOM y solo toca el DOM real cuando es necesario.
    </p>

    <h3>üîÅ Proceso de renderizado en React (paso a paso)</h3>

    <h4>1Ô∏è‚É£ Renderizado inicial</h4>
    <ul>
      <li>React crea el Virtual DOM</li>
      <li>Se genera el DOM real y se pinta la UI</li>
    </ul>
    <pre><code>Virtual DOM  ‚Üí  DOM Real  ‚Üí  Pantalla</code></pre>

    <h4>2Ô∏è‚É£ Cambio de estado (state o props)</h4>
    <p>Cuando cambia algo en la aplicaci√≥n:</p>
    <ul>
      <li>React no toca el DOM real directamente</li>
      <li>Crea un nuevo Virtual DOM</li>
    </ul>
    <pre><code>Virtual DOM (anterior)
Virtual DOM (nuevo)</code></pre>

    <h4>3Ô∏è‚É£ Diffing (comparaci√≥n)</h4>
    <p>React compara ambas versiones:</p>
    <pre><code>ANTES: &lt;h1&gt;Hola&lt;/h1&gt;
DESPU√âS: &lt;h1&gt;Hola Roge&lt;/h1&gt;</code></pre>
    <p>üëâ Solo detecta qu√© cambi√≥</p>

    <h4>4Ô∏è‚É£ Actualizaci√≥n eficiente</h4>
    <ul>
      <li>React actualiza solo ese nodo</li>
      <li>El resto del DOM queda intacto</li>
    </ul>
    <ul>
      <li>‚úÖ M√°s r√°pido</li>
      <li>‚úÖ M√°s eficiente</li>
      <li>‚úÖ Mejor rendimiento</li>
    </ul>

    <h3>üß† ¬øPor qu√© React es tan r√°pido?</h3>
    <p>Porque:</p>
    <ul>
      <li>Minimiza accesos al DOM real</li>
      <li>Agrupa cambios</li>
      <li>Actualiza solo lo necesario</li>
    </ul>
    <p>Este proceso es lo que se conoce como <strong>diffing + reconciliation</strong>.</p>

    <h3>üî• Tip avanzado</h3>
    <p>
      Aunque solemos hablar de "Virtual DOM", internamente React utiliza un sistema de
      <strong>reconciliaci√≥n basado en Fiber</strong>, que permite pausar, priorizar y
      reanudar renderizados para mejorar la experiencia del usuario.
    </p>

    <h3>üéØ Conclusi√≥n</h3>
    <p>
      <strong>React no actualiza la interfaz directamente. Primero piensa, compara y decide.</strong><br>
      Solo despu√©s modifica el DOM real, y √∫nicamente donde hace falta.
    </p>
  </div>

  <h2>Ejemplos de C√≥digo</h2>

  <h3>1. Renderizado Inicial con ReactDOM.createRoot</h3>
  <pre><code class="language-jsx">
// index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;App /&gt;);
  </code></pre>

  <h3>2. Definici√≥n de Componentes B√°sicos</h3>
  <pre><code class="language-jsx">
// App.js
import React from 'react';
import VideoList from './VideoList';

const App = () => {
return (
  &lt;div className="app" alt="Contenedor principal de la aplicaci√≥n"&gt;
      &lt;h1&gt;Bienvenido a Desarrollo √ötil&lt;/h1&gt;
      &lt;VideoList /&gt;
  &lt;/div&gt;
);
};

export default App;
  </code></pre>
  <pre><code class="language-jsx">
// VideoList.js
import React from 'react';
import VideoItem from './VideoItem';

const VideoList = () => {
return (
  &lt;div className="video-list" alt="Lista de videos"&gt;
      &lt;VideoItem title="Curso de React" duration="2 horas" /&gt;
      &lt;VideoItem title="Curso de Node.js" duration="3 horas" /&gt;
      &lt;VideoItem title="Curso de JavaScript" duration="1.5 horas" /&gt;
  &lt;/div&gt;
);
};

export default VideoList;
  </code></pre>
  <pre><code class="language-jsx">
// VideoItem.js
import React from 'react';

const VideoItem = ({ title, duration }) => {
return (
  &lt;div className="video-item" alt="Elemento individual de video"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;Duraci√≥n: {duration}&lt;/p&gt;
  &lt;/div&gt;
);
};

export default VideoItem;
  </code></pre>

  <h3>3. Uso de setTimeout para Demorar el Renderizado</h3>
  <p>
    Este ejemplo muestra c√≥mo se puede retrasar el renderizado de un componente
    utilizando setTimeout.
  </p>
  <pre><code class="language-jsx">
// index.js
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const Root = () => {
const [showApp, setShowApp] = useState(false);

useEffect(() => {
  const timer = setTimeout(() => {
      setShowApp(true);
  }, 5000); // 5 segundos de espera

  return () => clearTimeout(timer);
}, []);

return showApp ? &lt;App /&gt; : &lt;div alt="Mensaje de carga"&gt;Cargando...&lt;/div&gt;;
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Root /&gt;);
  </code></pre>

  <h3>4. Explicaci√≥n del Virtual DOM en el C√≥digo</h3>
  <p>
    Cuando ejecutas el renderizado inicial, React crea una representaci√≥n
    simplificada del DOM real. Por ejemplo, al definir componentes como App,
    VideoList y VideoItem, React construye una estructura de Virtual DOM que
    luego se compara con el DOM real para aplicar solo los cambios necesarios.
  </p>
  <pre><code class="language-jsx">
// Estructura simplificada del Virtual DOM
const virtualDOM = {
type: 'div',
props: { className: 'app', alt: 'Contenedor principal de la aplicaci√≥n' },
children: [
  {
      type: 'h1',
      props: {},
      children: ['Bienvenido a Desarrollo √ötil'],
  },
  {
      type: VideoList,
      props: {},
      children: [
          {
              type: VideoItem,
              props: { title: 'Curso de React', duration: '2 horas' },
              children: [],
          },
          // Otros VideoItem...
      ],
  },
],
};
  </code></pre>
  <p>
    Cuando el estado de alg√∫n componente cambia, React crea una nueva versi√≥n
    del Virtual DOM y lo compara con la anterior. Solo las diferencias
    detectadas se aplican al DOM real, lo que minimiza las operaciones costosas
    en el navegador y mejora el rendimiento.
  </p>

  <h3>5. Patr√≥n de Componente B√°sico</h3>
  <pre><code class="language-jsx">
import ComponentA from "./ComponentA";

export default function App() {
return (
&lt;div className="App" alt="Contenedor principal de la aplicaci√≥n"&gt;
&lt;ComponentA /&gt;
&lt;/div&gt;
);
}
  </code></pre>

  <h2>Conclusi√≥n</h2>
  <p>
    Entender el funcionamiento del Virtual DOM y el proceso de renderizado en
    React es esencial para desarrollar aplicaciones eficientes y optimizadas.
    Los ejemplos de c√≥digo proporcionados muestran c√≥mo se estructuran los
    componentes y c√≥mo React maneja las actualizaciones de manera eficiente.
  </p>
  <p>
    Para seguir profundizando en React, en pr√≥ximos contenidos se abordar√°n
    temas como los estados (states) y hooks, que permiten manejar la l√≥gica de
    la aplicaci√≥n de manera m√°s din√°mica y reactiva.
  </p>

  <section class="box">
    <h2>Life Cycle Relaci√≥n con el Virtual DOM y el Renderizado</h2>
    <p>
      El Virtual DOM juega un papel crucial en cada fase del ciclo de vida del
      componente:
    </p>

    <h3>Montaje:</h3>
    <ul>
      <li>
        Cuando un componente se monta, React crea su representaci√≥n en el
        Virtual DOM.
      </li>
      <li>
        El m√©todo render() (o el retorno en componentes funcionales) define qu√©
        se renderiza.
      </li>
      <li>
        React compara el Virtual DOM con el DOM real y actualiza solo lo
        necesario.
      </li>
    </ul>

    <h3>Actualizaci√≥n:</h3>
    <ul>
      <li>
        Al cambiar el estado o las props, React genera una nueva versi√≥n del
        Virtual DOM.
      </li>
      <li>
        Utiliza el algoritmo de diffing para identificar las diferencias entre
        la versi√≥n anterior y la nueva.
      </li>
      <li>
        Solo las partes del DOM real que han cambiado se actualizan, optimizando
        el rendimiento.
      </li>
    </ul>

    <h3>Desmontaje:</h3>
    <ul>
      <li>React elimina la representaci√≥n del componente en el Virtual DOM.</li>
      <li>
        Se ejecutan los m√©todos de limpieza (componentWillUnmount o la funci√≥n
        de limpieza en useEffect).
      </li>
    </ul>

    <p>
      Este enfoque permite que React maneje eficientemente las actualizaciones
      de la interfaz, minimizando las manipulaciones directas y costosas del DOM
      real, lo que resulta en aplicaciones m√°s r√°pidas y responsivas.
    </p>

    <h2>Ejemplos Pr√°cticos del Ciclo de Vida</h2>
    <p>
      A continuaci√≥n, se presentan ejemplos que demuestran c√≥mo las diferentes
      fases del ciclo de vida interact√∫an con el Virtual DOM y el proceso de
      renderizado.
    </p>

    <h3>Ejemplo 1: Montaje y Actualizaci√≥n con Componentes Funcionales</h3>
    <pre><code class="language-javascript">
  import React, { useState, useEffect } from 'react';
  import ReactDOM from 'react-dom/client';
  
  const VideoItem = ({ title, duration }) => {
    useEffect(() => {
      console.log(`VideoItem Montado: ${title}`);
  
      return () => {
        console.log(`VideoItem Desmontado: ${title}`);
      };
    }, [title]);
  
    return (
      &lt;div className="video-item"&gt;
        &lt;h2&gt;{title}&lt;/h2&gt;
        &lt;p&gt;Duraci√≥n: {duration}&lt;/p&gt;
      &lt;/div&gt;
    );
  };
  
  const VideoList = () => {
    const [videos, setVideos] = useState([
      { id: 1, title: 'Curso de React', duration: '2 horas' },
      { id: 2, title: 'Curso de Node.js', duration: '3 horas' },
    ]);
  
    const addVideo = () => {
      const newVideo = {
        id: videos.length + 1,
        title: `Curso de JavaScript ${videos.length + 1}`,
        duration: '1.5 horas',
      };
      setVideos([...videos, newVideo]);
    };
  
    return (
      &lt;div className="video-list"&gt;
        {videos.map((video) => (
          &lt;VideoItem key={video.id} title={video.title} duration={video.duration} /&gt;
        ))}
        &lt;button onClick={addVideo}&gt;A√±adir Video&lt;/button&gt;
      &lt;/div&gt;
    );
  };
  
  const App = () => {
    return (
      &lt;div className="app"&gt;
        &lt;h1&gt;Bienvenido a Desarrollo √ötil&lt;/h1&gt;
        &lt;VideoList /&gt;
      &lt;/div&gt;
    );
  };
  
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(&lt;App /&gt;);
    </code></pre>

    <h3>Explicaci√≥n:</h3>
    <h4>Montaje:</h4>
    <p>
      Al cargar la aplicaci√≥n, se montan los componentes App, VideoList y los
      primeros VideoItem. Cada VideoItem ejecuta el useEffect que registra en la
      consola que ha sido montado.
    </p>

    <h4>Actualizaci√≥n:</h4>
    <p>
      Al hacer clic en "A√±adir Video", se actualiza el estado en VideoList, lo
      que provoca una nueva renderizaci√≥n. Se monta un nuevo VideoItem,
      ejecutando nuevamente el useEffect.
    </p>

    <h4>Desmontaje:</h4>
    <p>
      Si se implementara una funcionalidad para eliminar videos, al desmontar un
      VideoItem, se ejecutar√≠a la funci√≥n de limpieza en useEffect, registrando
      en la consola que ha sido desmontado.
    </p>

    <h3>Ejemplo 2: Optimizaci√≥n con shouldComponentUpdate y React.memo</h3>

    <h4>Componentes de Clase:</h4>
    <pre><code class="language-javascript">
  import React, { Component } from 'react';
  
  class VideoItem extends Component {
    shouldComponentUpdate(nextProps) {
      // Solo actualizar si el t√≠tulo cambia
      return nextProps.title !== this.props.title;
    }
  
    render() {
      const { title, duration } = this.props;
      return (
        &lt;div className="video-item"&gt;
          &lt;h2&gt;{title}&lt;/h2&gt;
          &lt;p&gt;Duraci√≥n: {duration}&lt;/p&gt;
        &lt;/div&gt;
      );
    }
  }
  
  export default VideoItem;
    </code></pre>

    <h4>Componentes Funcionales con React.memo:</h4>
    <pre><code class="language-javascript">
  import React from 'react';
  
  const VideoItem = React.memo(({ title, duration }) => {
    console.log(`Renderizando VideoItem: ${title}`);
    return (
      &lt;div className="video-item"&gt;
        &lt;h2&gt;{title}&lt;/h2&gt;
        &lt;p&gt;Duraci√≥n: {duration}&lt;/p&gt;
      &lt;/div&gt;
    );
  }, (prevProps, nextProps) => {
    return prevProps.title === nextProps.title;
  });
  
  export default VideoItem;
    </code></pre>

    <h3>Explicaci√≥n:</h3>
    <h4>Componentes de Clase:</h4>
    <p>
      shouldComponentUpdate evita re-renderizados innecesarios verificando si
      las props han cambiado.
    </p>

    <h4>Componentes Funcionales:</h4>
    <p>
      React.memo optimiza el componente funcional evitando re-renderizados si
      las props no han cambiado. La funci√≥n de comparaci√≥n personalizada
      (prevProps, nextProps) determina si el componente debe re-renderizarse.
    </p>
  </section>

  <div class="links">
    <h3>Enlaces Relacionados:</h3>
    <a
      href="https://chatgpt.com/c/670c59c3-c770-8008-add4-1e745b1a1f0a"
      target="_blank"
      >Virtual Dom</a
    >
    <a
      href="https://chatgpt.com/share/670c5ab2-8204-8008-a459-82505f6802ae"
      target="_blank"
      >Virtual Dom y renderizado</a
    >
  </div>
</section>
